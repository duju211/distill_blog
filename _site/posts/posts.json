[
  {
    "path": "posts/strava-data/",
    "title": "Strava Data",
    "description": "Article on how to effectively scrape and store Strava data using the `targets`\npackage",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2022-03-03",
    "categories": [],
    "contents": "\r\nI am an avid runner and cyclist. For the past couple of years, I have recorded almost all my activities on some kind of GPS device.\r\nI record my runs with a Garmin device and my bike rides with a Wahoo device, and I synchronize both accounts on Strava. I figured that it would be nice to directly access my data from my Strava account.\r\nIn the following text, I will describe the progress to get Strava data into R, process the data, and then create a visualization of activity routes.\r\nYou will need the following packages:\r\n\r\n\r\nlibrary(tarchetypes)\r\nlibrary(conflicted)\r\nlibrary(tidyverse)\r\nlibrary(lubridate)\r\nlibrary(jsonlite)\r\nlibrary(targets)\r\nlibrary(httpuv)\r\nlibrary(arrow)\r\nlibrary(httr)\r\nlibrary(pins)\r\nlibrary(httr)\r\nlibrary(glue)\r\nlibrary(fs)\r\n\r\nconflict_prefer(\"filter\", \"dplyr\")\r\n\r\n\r\n\r\nData\r\nThe whole data pipeline is implemented with the help of the targets package. You can learn more about the package and its functionalities here.\r\nIn order to reproduce the analysis, perform the following steps:\r\nClone the repository: https://github.com/duju211/pin_strava\r\nInstall the packages listed in the libraries.R file\r\nRun the target pipeline by executing targets::tar_make() command\r\nFollow the instructions printed in the console\r\nTarget Plan\r\nWe will go through the most important targets in detail.\r\nOAuth Dance from R\r\nThe Strava API requires an ‘OAuth dance’, described below.\r\nCreate an OAuth Strava app\r\nTo get access to your Strava data from R, you must first create a Strava API. The steps are documented on the Strava Developer site. While creating the app, you’ll have to give it a name. In my case, I named it r_api.\r\nAfter you have created your personal API, you can find your Client ID and Client Secret variables in the Strava API settings. Save the Client ID as STRAVA_KEY and the Client Secret as STRAVA_SECRET in your R environment.\r\n\r\nYou can edit your R environment by running usethis::edit_r_environ(), saving the keys, and then restarting R.\r\nSTRAVA_KEY=<Client ID>\r\nSTRAVA_SECRET=<Client Secret>\r\nThe function define_strava_app shown below creates the OAuth app:\r\n\r\n\r\ndefine_strava_app <- function() {\r\n  if (Sys.getenv(\"STRAVA_KEY\") == \"\" | Sys.getenv(\"STRAVA_SECRET\") == \"\")\r\n    stop(str_glue(\r\n      \"Please set system variables 'STRAVA_KEY' and 'STRAVA_SECRET' before \",\r\n      \"continuing. How you can create these variables is described here: \",\r\n      \"https://developers.strava.com/docs/getting-started/. \",\r\n      \"You can set the system variables with the `usethis::edit_r_environ` \",\r\n      \"function.\"))\r\n\r\n  oauth_app(\r\n    appname = \"r_api\",\r\n    key = Sys.getenv(\"STRAVA_KEY\"),\r\n    secret = Sys.getenv(\"STRAVA_SECRET\"))\r\n}\r\n\r\n\r\n\r\nDefine an endpoint\r\nDefine an endpoint called my_endpoint using the function define_strava_endpoint.\r\nThe authorize parameter describes the authorization url and the access argument exchanges the authenticated token.\r\n\r\n\r\ndefine_strava_endpoint <- function() {\r\n  oauth_endpoint(\r\n    request = NULL,\r\n    authorize = \"https://www.strava.com/oauth/authorize\",\r\n    access = \"https://www.strava.com/oauth/token\")\r\n}\r\n\r\n\r\n\r\nThe final authentication step\r\nBefore you can execute the following steps, you have to authenticate the API in the web browser.\r\n\r\n\r\ndefine_strava_sig <- function(endpoint, app) {\r\n  oauth2.0_token(\r\n    endpoint, app,\r\n    scope = \"activity:read_all,activity:read,profile:read_all\",\r\n    type = NULL, use_oob = FALSE, as_header = FALSE,\r\n    use_basic_auth = FALSE, cache = FALSE)\r\n}\r\n\r\n\r\n\r\nThe information in my_sig can now be used to access Strava data. Set the cue_mode of the target to ‘always’ so that the following API calls are always executed with an up-to-date authorization token.\r\nCurrent authenticated user\r\nDownload information about the currently authenticated user. When preprocessing the data, the columns shoes, clubs and bikes need special attention, because they can contain multiple entries and can be interpreted as list columns.\r\n\r\n\r\nactive_user <- function(access_token, user_list_cols, meas_board) {\r\n  athlete_url <- parse_url(\"https://www.strava.com/api/v3/athlete\")\r\n\r\n  r <- athlete_url %>%\r\n    modify_url(\r\n      query = list(access_token = access_token)) %>%\r\n    GET()\r\n\r\n  user_list <- content(r, as = \"text\") %>%\r\n    fromJSON()\r\n\r\n  df_user <- user_list[\r\n    map_lgl(user_list, ~ !is.null(.x))\r\n    & map_lgl(names(user_list), ~ !(.x %in% user_list_cols))] %>%\r\n    as_tibble()\r\n\r\n  list_cols <- user_list[names(user_list) %in% user_list_cols] %>%\r\n    map(as_tibble)\r\n\r\n  for (i in seq_along(list_cols)) {\r\n    df_user[[names(list_cols)[[i]]]] <- list(list_cols[[i]])\r\n  }\r\n  df_user\r\n}\r\n\r\n\r\n\r\nIn the end there is a data frame with one row for the currently authenticated user:\r\n\r\n# A tibble: 1 x 27\r\n        id resource_state firstname lastname city  state country sex  \r\n     <int>          <int> <chr>     <chr>    <chr> <chr> <chr>   <chr>\r\n1 26845822              3 \"Julian \" During   Bali~ Bade~ Germany M    \r\n# ... with 19 more variables: premium <lgl>, summit <lgl>,\r\n#   created_at <chr>, updated_at <chr>, badge_type_id <int>,\r\n#   weight <dbl>, profile_medium <chr>, profile <chr>, blocked <lgl>,\r\n#   can_follow <lgl>, follower_count <int>, friend_count <int>,\r\n#   mutual_friend_count <int>, athlete_type <int>,\r\n#   date_preference <chr>, measurement_preference <chr>,\r\n#   clubs <list>, bikes <list>, shoes <list>\r\n\r\nActivities\r\nLoad a data frame that gives an overview of all the activities from the data. Because the total number of activities is unknown, use a while loop. It will break the execution of the loop if there are no more activities to read.\r\n\r\n\r\nread_all_activities <- function(access_token, active_user_id) {\r\n  activities_url <- parse_url(\r\n    \"https://www.strava.com/api/v3/athlete/activities\")\r\n\r\n  act_vec <- vector(mode = \"list\")\r\n  df_act <- tibble(init = \"init\")\r\n  i <- 1L\r\n\r\n  while (nrow(df_act) != 0) {\r\n    r <- activities_url %>%\r\n      modify_url(\r\n        query = list(\r\n          access_token = access_token,\r\n          page = i)) %>%\r\n      GET()\r\n\r\n    stop_for_status(r)\r\n\r\n    df_act <- content(r, as = \"text\") %>%\r\n      fromJSON(flatten = TRUE) %>%\r\n      as_tibble()\r\n    if (nrow(df_act) != 0)\r\n      act_vec[[i]] <- df_act\r\n    i <- i + 1L\r\n  }\r\n\r\n  act_vec %>%\r\n    bind_rows() %>%\r\n    mutate(\r\n      start_date = ymd_hms(start_date),\r\n      active_user_id = active_user_id)\r\n}\r\n\r\n\r\n\r\nThe resulting data frame consists of one row per activity:\r\n\r\n# A tibble: 648 x 62\r\n   resource_state name               distance moving_time elapsed_time\r\n            <int> <chr>                 <dbl>       <int>        <int>\r\n 1              2 \"Test manueller E~    3010         3600         3600\r\n 2              2 \"Test Yoga\"              0           61           61\r\n 3              2 \"Tieringen \\U0001~    8055.        3208         3269\r\n 4              2 \"Sunset \\U0001f30~    7543.        3107         3141\r\n 5              2 \"Hangen Sprint \"      9275.        3715         3871\r\n 6              2 \"\\U0001f499\\U0001~    7742.        3115         3161\r\n 7              2 \"22222 \\U0001f92a\"    7748.        3203         3273\r\n 8              2 \"Storm Run\"           6771.        2845         2915\r\n 9              2 \"Union Ride\"         44468         6730         7321\r\n10              2 \"February Nightca~    6701.        2839         2850\r\n# ... with 638 more rows, and 57 more variables:\r\n#   total_elevation_gain <dbl>, type <chr>, workout_type <int>,\r\n#   id <dbl>, start_date <dttm>, start_date_local <chr>,\r\n#   timezone <chr>, utc_offset <dbl>, location_city <lgl>,\r\n#   location_state <lgl>, location_country <chr>,\r\n#   achievement_count <int>, kudos_count <int>, comment_count <int>,\r\n#   athlete_count <int>, photo_count <int>, trainer <lgl>, ...\r\n\r\nMake sure that all ID columns have a character format and improve the column names.\r\n\r\n\r\npre_process_act <- function(df_act_raw, active_user_id, meas_board) {\r\n  df_act_raw %>%\r\n    mutate(across(contains(\"id\"), as.character)) %>%\r\n    rename(athlete_id = `athlete.id`)\r\n}\r\n\r\n\r\n\r\nExtract ids of all activities. Exclude activities which were recorded manually, because they don’t include additional data:\r\n\r\n\r\nrel_act_ids <- function(df_act) {\r\n  df_act %>%\r\n    filter(!manual) %>%\r\n    pull(id)\r\n}\r\n\r\n\r\n\r\nMeasurements\r\nA ‘stream’ is a nested list (JSON format) with all available measurements of the corresponding activity.\r\nTo get the available variables and turn the result into a data frame, define a helper function read_activity_stream. This function takes an ID of an activity and an authentication token, which you created earlier.\r\nPreprocess and unnest the data in this function. The column latlng needs special attention, because it contains latitude and longitude information. Separate the two measurements before unnesting all list columns.\r\n\r\n\r\nread_activity_stream <- function(id, active_user_id, access_token) {\r\n  act_url <- parse_url(stringr::str_glue(\r\n    \"https://www.strava.com/api/v3/activities/{id}/streams\"))\r\n\r\n  r <- modify_url(\r\n    act_url,\r\n    query = list(\r\n      access_token = access_token,\r\n      keys = str_glue(\r\n        \"distance,time,latlng,altitude,velocity_smooth,heartrate,cadence,\",\r\n        \"watts,temp,moving,grade_smooth\"))) %>%\r\n    GET()\r\n\r\n  stop_for_status(r)\r\n\r\n  df_stream_raw <- fromJSON(content(r, as = \"text\"), flatten = TRUE) %>%\r\n    as_tibble() %>%\r\n    mutate(id = id) %>%\r\n    pivot_wider(names_from = type, values_from = data)\r\n\r\n  if (\"latlng\" %in% colnames(df_stream_raw)) {\r\n    df_stream <- df_stream_raw %>%\r\n      mutate(\r\n        lat = map(\r\n          .x = latlng, .f = ~ .x[, 1]),\r\n        lng = map(\r\n          .x = latlng, .f = ~ .x[, 2])) %>%\r\n      select(-latlng)\r\n  } else {\r\n    df_stream <- df_stream_raw\r\n  }\r\n\r\n  df_stream %>%\r\n    unnest(where(is_list)) %>%\r\n    mutate(id = id)\r\n}\r\n\r\n\r\n\r\nDo this for every id. Pin the resulting data frames to the local strava_data_26845822 board as an file of type ‘arrow’. By doing so we can later effectively query the data.\r\n\r\nThe name of the board is determined by the currently logged in user and will have a different name, if you run the pipeline.\r\n\r\n\r\npin_meas <- function(act_id, active_user_id, access_token, meas_board) {\r\n  pin_name <- paste0(\"df_\", act_id, \"_\", active_user_id)\r\n  meas <- read_activity_stream(act_id, active_user_id, access_token)\r\n  pin_write(meas_board, meas, pin_name, type = \"arrow\")\r\n}\r\n\r\n\r\n\r\nVisualisation\r\nVisualize the final data by displaying the geospatial information in the data. Join all the activities into one data frame. To do this, get the paths to all the measurement files:\r\n\r\n\r\nmeas_paths <- function(board_name) {\r\n  dir_ls(\r\n    board_name, type = \"file\", regexp = \"df_\\\\d.*\\\\.arrow$\", recurse = TRUE)\r\n}\r\n\r\n\r\n\r\nInsert them all into a duckdb and select relevant columns:\r\n\r\n\r\nmeas_all <- function(paths_meas) {\r\n  act_col_types <- schema(\r\n    moving = boolean(), velocity_smooth = double(),\r\n    grade_smooth = double(), distance = double(),\r\n    altitude = double(), heartrate = int32(), time = int32(),\r\n    lat = double(), lng = double(), cadence = int32(),\r\n    watts = int32(), id = string())\r\n\r\n  open_dataset(paths_meas, format = \"arrow\", schema = act_col_types) %>%\r\n    to_duckdb() %>%\r\n    select(id, lat, lng) %>%\r\n    filter(!is.na(lat) & !is.na(lng)) %>%\r\n    collect()\r\n}\r\n\r\n\r\n\r\n\r\n# A tibble: 2,252,282 x 3\r\n   id           lat   lng\r\n   <chr>      <dbl> <dbl>\r\n 1 1327205128  48.2  9.02\r\n 2 1327205128  48.2  9.02\r\n 3 1327205128  48.2  9.02\r\n 4 1327205128  48.2  9.02\r\n 5 1327205128  48.2  9.02\r\n 6 1327205128  48.2  9.02\r\n 7 1327205128  48.2  9.02\r\n 8 1327205128  48.2  9.02\r\n 9 1327205128  48.2  9.02\r\n10 1327205128  48.2  9.02\r\n# ... with 2,252,272 more rows\r\n\r\nIn the final plot every facet is one activity. Keep the rest of the plot as minimal as possible.\r\n\r\n\r\nvis_meas <- function(df_meas_pro) {\r\n  df_meas_pro %>%\r\n    ggplot(aes(x = lng, y = lat)) +\r\n    geom_path() +\r\n    facet_wrap(~ id, scales = \"free\") +\r\n    theme(\r\n      axis.line = element_blank(),\r\n      axis.text.x = element_blank(),\r\n      axis.text.y = element_blank(),\r\n      axis.ticks = element_blank(),\r\n      axis.title.x = element_blank(),\r\n      axis.title.y = element_blank(),\r\n      legend.position = \"bottom\",\r\n      panel.background = element_blank(),\r\n      panel.border = element_blank(),\r\n      panel.grid.major = element_blank(),\r\n      panel.grid.minor = element_blank(),\r\n      plot.background = element_blank(),\r\n      strip.text = element_blank())\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nAnd there it is: All your Strava data in a few tidy data frames and a nice-looking plot. Future updates to the data shouldn’t take too long, because only measurements from new activities will be downloaded. With all your Strava data up to date, there are a lot of appealing possibilities for further data analyses of your fitness data.\r\n\r\n\r\n\r\n",
    "preview": "posts/strava-data/distill-preview.png",
    "last_modified": "2022-03-03T19:35:39+01:00",
    "input_file": {},
    "preview_width": 2100,
    "preview_height": 2100
  },
  {
    "path": "posts/hour-record/",
    "title": "Hour Record",
    "description": "Article about the development of the cycling hour record",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-11-05",
    "categories": [],
    "contents": "\r\nIdea\r\nVisualise the development of the cycling hour record. It is a record attempt of cyclyst, who try to cover the longest possible distance in one hour. Since 2014 there are unified rules for the hour record. Since then there were 6 different record holders. Explore how these records compare to each other.\r\nThe analysis is realised in a target plan. Look at the graph representation of this plan:\r\n\r\n\r\n{\"x\":{\"nodes\":{\"name\":[\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"hour_record\",\"hour_record_post\",\"rel_urls\",\"vis_average_speed\",\"time_splits\",\"time_splits_raw\"],\"type\":[\"stem\",\"pattern\",\"stem\",\"stem\",\"stem\",\"stem\",\"function\",\"function\",\"function\"],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"outdated\",\"started\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\"],\"seconds\":[0.16,0.9,0.01,8.69,10.78,0,null,null,null],\"bytes\":[1181,16261,42718,1885484,1713403,151,null,null,null],\"branches\":[null,6,null,null,null,null,null,null,null],\"id\":[\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"hour_record\",\"hour_record_post\",\"rel_urls\",\"vis_average_speed\",\"time_splits\",\"time_splits_raw\"],\"label\":[\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"hour_record\",\"hour_record_post\",\"rel_urls\",\"vis_average_speed\",\"time_splits\",\"time_splits_raw\"],\"level\":[3,2,4,5,5,1,1,1,1],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#78B7C5\",\"#DC863B\",\"#354823\",\"#354823\",\"#354823\",\"#354823\"],\"shape\":[\"dot\",\"square\",\"dot\",\"dot\",\"dot\",\"dot\",\"triangle\",\"triangle\",\"triangle\"]},\"edges\":{\"from\":[\"df_time_splits\",\"vis_average_speed\",\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"rel_urls\",\"rel_urls\",\"time_splits_raw\",\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"rel_urls\",\"df_time_splits_raw\",\"time_splits\"],\"to\":[\"gg_average_speed\",\"gg_average_speed\",\"hour_record_post\",\"hour_record_post\",\"hour_record_post\",\"hour_record_post\",\"df_time_splits_raw\",\"df_time_splits_raw\",\"hour_record\",\"hour_record\",\"hour_record\",\"hour_record\",\"df_time_splits\",\"df_time_splits\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Outdated\",\"Started\",\"Stem\",\"Pattern\",\"Function\"],\"color\":[\"#354823\",\"#78B7C5\",\"#DC863B\",\"#899DA4\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"square\",\"triangle\"]},\"nodesToDataframe\":true}},\"evals\":[],\"jsHooks\":[]}\r\nData\r\nGet the data from the following urls: http://www.wolfgang-menn.de/voigt.htm, http://www.wolfgang-menn.de/braendle.htm, http://www.wolfgang-menn.de/dennis.htm, http://www.wolfgang-menn.de/dowsett.htm, http://www.wolfgang-menn.de/wiggins.htm, http://www.wolfgang-menn.de/campenaerts.htm\r\nMap over the different urls and save the data along with the url adress:\r\n\r\n\r\ntime_splits_raw <- function(url) {\r\n  resp <- request(url) |>\r\n    req_perform()\r\n\r\n  df_splits <- resp |>\r\n    resp_body_html() |>\r\n    html_elements(xpath = \"/html/body/div/table\") |>\r\n    html_table() |>\r\n    first() |>\r\n    mutate(across(everything(), as.character))\r\n\r\n  tibble(url = url, time_splits = list(df_splits))\r\n}\r\n\r\n\r\n\r\n\r\n# A tibble: 6 x 2\r\n  url                                         time_splits        \r\n  <chr>                                       <list>             \r\n1 http://www.wolfgang-menn.de/voigt.htm       <tibble [28 x 104]>\r\n2 http://www.wolfgang-menn.de/braendle.htm    <tibble [23 x 79]> \r\n3 http://www.wolfgang-menn.de/dennis.htm      <tibble [25 x 89]> \r\n4 http://www.wolfgang-menn.de/dowsett.htm     <tibble [25 x 89]> \r\n5 http://www.wolfgang-menn.de/wiggins.htm     <tibble [27 x 99]> \r\n6 http://www.wolfgang-menn.de/campenaerts.htm <tibble [23 x 99]> \r\n\r\nPreprocessing of the raw data. Extract the rider name and preprocess the kpi columns.\r\n\r\n\r\ntime_splits <- function(df_time_splits_raw) {\r\n  df_time_splits_raw |>\r\n    mutate(time_splits = map(time_splits, ~ filter(.x, str_detect(X1, \"^\\\\d+$\")))) |>\r\n    unnest(time_splits) |>\r\n    select(where(~ !all(is.na(.x)))) |>\r\n    transmute(\r\n      rider = str_to_title(str_remove(\r\n        map_chr(str_split(url, \"/\"), 4), \"\\\\.htm\")),\r\n      km = parse_integer(X1),\r\n      time = ms(str_remove(X4, \"\\\\.\\\\d+$\")), km_h = parse_number(X5)) |>\r\n    filter(!is.na(km_h))\r\n}\r\n\r\n\r\n\r\n\r\n# A tibble: 79 x 4\r\n   rider    km time      km_h\r\n   <chr> <int> <Period> <dbl>\r\n 1 Voigt     1 1M 14S    48.6\r\n 2 Voigt     5 5M 56S    50.5\r\n 3 Voigt    10 11M 48S   50.8\r\n 4 Voigt    15 17M 42S   50.8\r\n 5 Voigt    20 23M 39S   50.7\r\n 6 Voigt    25 29M 36S   50.7\r\n 7 Voigt    30 35M 32S   50.6\r\n 8 Voigt    35 41M 27S   50.7\r\n 9 Voigt    40 47M 26S   50.8\r\n10 Voigt    45 53M 1S    50.9\r\n# ... with 69 more rows\r\n\r\nVisualisation\r\nPlot the development of the average speeds. Differentiate the riders by color:\r\n\r\n\r\nvis_average_speed <- function(df_time_splits) {\r\n  df_time_splits |>\r\n    ggplot(aes(x = km, y = km_h, color = rider)) +\r\n      geom_point() +\r\n      geom_line() +\r\n      labs(\r\n        y = \"Average Speed\", x = \"Kilometer\",\r\n        title = \"Development of Speeds by Hour Record Attempt\",\r\n        subtitle = \"Different Riders are represented by color\") +\r\n      theme_light() +\r\n      theme(legend.position = \"bottom\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/hour-record/distill-preview.png",
    "last_modified": "2021-11-05T23:14:31+01:00",
    "input_file": {}
  },
  {
    "path": "posts/hex_sticker/",
    "title": "Hex Sticker",
    "description": "How to create a hex sticker for a new package",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-05-23",
    "categories": [],
    "contents": "\r\nIn this post, I want to describe how I created a hex sticker for one of my shiny apps. The app itself lets users interactively explore their Strava data.\r\nBecause I called the app SummitR, I decided to display one of the most famous summit finishes in cycling history: Alpe d’Huez.\r\nI am using the following packages:\r\n\r\n\r\nlibrary(hexSticker)\r\nlibrary(tidyverse)\r\nlibrary(pins)\r\n\r\n\r\n\r\nThe hexSticker package is used to create the final sticker.\r\nBecause I already climbed Alpe d’Huez on a previous occasion, I can get the data already prepared from a private github repository. The data in the corresponding repository is organised as a pin:\r\n\r\n\r\nalpe_dhuez_id <- \"1714646144\"\r\nathlete_id <- \"26845822\"\r\n\r\nboard_register_github(repo = \"duju211/strava_act\", branch = \"master\")\r\n\r\ndf_act <- pin_get(\r\n  str_glue(\"act_{alpe_dhuez_id}_{athlete_id}\"), board = \"github\")\r\n\r\nboard_disconnect(\"github\")\r\n\r\n\r\n\r\nIn raw table form the data of the activity looks like this:\r\n\r\n# A tibble: 5,326 x 11\r\n   moving velocity_smooth grade_smooth distance altitude  time   lat\r\n   <lgl>            <dbl>        <dbl>    <dbl>    <dbl> <int> <dbl>\r\n 1 FALSE              0            8.6      0       787      0  45.1\r\n 2 TRUE               0            8.6      2.1     787.     1  45.1\r\n 3 TRUE               2.3          8.6      4.5     787.     2  45.1\r\n 4 TRUE               2.3         10        7       788.     3  45.1\r\n 5 TRUE               2.3         11.9      9.3     788.     4  45.1\r\n 6 TRUE               2.3         12       11.6     788      5  45.1\r\n 7 TRUE               2.4         11.9     14.1     788.     6  45.1\r\n 8 TRUE               2.4         13.6     16.3     789.     7  45.1\r\n 9 TRUE               2.3         12       18.7     789      8  45.1\r\n10 TRUE               2.4         12.6     21.1     789.     9  45.1\r\n# ... with 5,316 more rows, and 4 more variables: lng <dbl>,\r\n#   heartrate <int>, cadence <int>, watts <int>\r\n\r\nCreate a minimalistic plot of the activity. Only take variables lat and lng into account:\r\n\r\n\r\ngg_act <- df_act %>% \r\n  ggplot(aes(x = lng, y = lat)) +\r\n  geom_path(color = \"white\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\nPlot the path of the activity on a black background:\r\n\r\n\r\ngg_act +\r\n  theme_dark()\r\n\r\n\r\n\r\n\r\nSave the finished hex sticker as result. Use the official Strava color as background color.\r\n\r\n\r\nsticker(\r\n  gg_act, package=\"SummitR\", p_size=20, s_x=1.1, s_y=.75, s_width=1.3,\r\n  s_height=1, h_fill = \"#fc4c02\", h_color = \"white\",\r\n  filename=\"_posts/hex_sticker/hex_sticker.png\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/hex_sticker/distill-preview.png",
    "last_modified": "2021-05-23T20:22:01+02:00",
    "input_file": {}
  },
  {
    "path": "posts/transalp/",
    "title": "Getting Over It",
    "description": "Visualising my Transalp bike ride",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-05-23",
    "categories": [],
    "contents": "\r\nThis summer I crossed the alps with my road bike. I’ve recorded the whole ride and as a nice memory, I would like to visualise this ride.\r\nA short time ago I’ve discovered the awesome R package drake. The use of this package transformed the way I do my analysis and it helps me to make my post more reproducible. The following blog post describes the underlying workflow, after which I’ve developed the underlying package transalp for this post.\r\nData\r\nAt first you have to install the package from github. Then you have to load it.\r\n\r\n\r\nremotes::install_github(\"duju211/transalp\")\r\n\r\nlibrary(transalp)\r\n\r\n\r\n\r\nLoad the other necessary libraries:\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(patchwork)\r\nlibrary(drake)\r\nlibrary(here)\r\nlibrary(fs)\r\n\r\n\r\n\r\nThe package includes the underlying data:\r\n\r\n\r\ndf_act_meas_raw <- transalp::df_act_meas\r\n\r\n\r\n\r\n\r\n# A tibble: 90,917 x 10\r\n   id         act_date   moving velocity_smooth grade_smooth distance\r\n   <chr>      <date>     <lgl>            <dbl>        <dbl>    <dbl>\r\n 1 3669729902 2020-06-25 FALSE              0            0        0  \r\n 2 3669729902 2020-06-25 FALSE              0            0        0.9\r\n 3 3669729902 2020-06-25 TRUE               0          -44.6      4.6\r\n 4 3669729902 2020-06-25 TRUE               0            1.4      8.4\r\n 5 3669729902 2020-06-25 TRUE               0            2.8     12.1\r\n 6 3669729902 2020-06-25 TRUE               0            2.8     15.6\r\n 7 3669729902 2020-06-25 TRUE               0            1.4     19.1\r\n 8 3669729902 2020-06-25 TRUE               3.6          1.4     22.5\r\n 9 3669729902 2020-06-25 TRUE               3.5          0       26  \r\n10 3669729902 2020-06-25 TRUE               3.5          1.6     29.5\r\n# ... with 90,907 more rows, and 4 more variables: altitude <dbl>,\r\n#   time <int>, lat <dbl>, lng <dbl>\r\n\r\nPreprocessing\r\nLook at the first function:\r\n\r\n\r\n#' Function to preprocess measurements of the included activities.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return Preprocessed activities\r\n#' @export\r\n#'\r\n#' @examples\r\n#' pre_process_meas(df_act_meas)\r\npre_process_meas <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    dplyr::mutate(\r\n      act_date_chr = as.character(act_date),\r\n      altitude_norm = altitude / max(altitude)) %>%\r\n    dplyr::group_by(id) %>%\r\n    dplyr::mutate(distance_norm = distance / max(distance)) %>%\r\n    dplyr::ungroup()\r\n}\r\n\r\n\r\n\r\nThe function does some basic preprocessing on the included activities:\r\nTurn activity date into character (for easier plotting)\r\nNormalize altitude and distance\r\n\r\n\r\ndf_act_meas <- pre_process_meas(df_act_meas_raw)\r\n\r\n\r\n\r\nNest the data frame by id and act_date_chr. Create a new sf column with the geospatial information of the activities:\r\n\r\n\r\n#' Turn every activity into an sf object. Nest the data frame by 'id' and\r\n#' 'act_date_chr' to do this.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return sf object\r\n#' @export\r\n#'\r\n#' @examples\r\nconvert_to_sf <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    tidyr::nest(act_data = -c(id, act_date_chr)) %>%\r\n    dplyr::mutate(\r\n      line = purrr::map(\r\n        act_data,\r\n        ~ sf::st_linestring(as.matrix(.x[, c(\"lng\", \"lat\", \"altitude\")]))),\r\n      geom = purrr::map(line, sf::st_sfc, crs = 4326)) %>%\r\n    sf::st_as_sf()\r\n}\r\n\r\n\r\n\r\n\r\n\r\nsf_act_meas <- convert_to_sf(df_act_meas)\r\n\r\n\r\n\r\n\r\nSimple feature collection with 5 features and 4 fields\r\nGeometry type: LINESTRING\r\nDimension:     XYZ\r\nBounding box:  xmin: 8.317612 ymin: 46.0061 xmax: 9.035269 ymax: 48.21307\r\nz_range:       zmin: 206.8 zmax: 2477.6\r\nCRS:           NA\r\n# A tibble: 5 x 5\r\n  id     act_date_chr act_data                             line geom  \r\n  <chr>  <chr>        <list>                       <LINESTRING> <list>\r\n1 36697~ 2020-06-25   <tibble [~ Z (8.596761 46.63501 1451.6, ~ <LINE~\r\n2 36646~ 2020-06-24   <tibble [~ Z (8.602206 46.63612 1510.2, ~ <LINE~\r\n3 36590~ 2020-06-23   <tibble [~ Z (8.625703 46.90152 447, 8.6~ <LINE~\r\n4 36542~ 2020-06-22   <tibble [~ Z (8.741265 47.49397 432, 8.7~ <LINE~\r\n5 36504~ 2020-06-21   <tibble [~ Z (9.021049 48.21307 750.2, 9~ <LINE~\r\n\r\nExtract the start point of every tour except for the last one. Extract the end point for this tour.\r\n\r\n\r\n#' Extract points of interest.\r\n#'\r\n#' @param sf_act_meas\r\n#'\r\n#' @return Data frame with points of interest\r\n#' @export\r\n#'\r\n#' @examples\r\nextract_poi <- function(sf_act_meas) {\r\n  sf_act_meas %>%\r\n    tibble::as_tibble() %>%\r\n    dplyr::transmute(\r\n      id, first_row = purrr::map(act_data, ~ .x[1,]),\r\n      last_row = purrr::map(act_data, ~ .x[nrow(.x), ]),\r\n      decisive_row = dplyr::if_else(id == \"3669729902\", last_row, first_row)) %>%\r\n    tidyr::unnest(decisive_row) %>%\r\n    dplyr::select(where(purrr::negate(purrr::is_list))) %>%\r\n    dplyr::mutate(\r\n      poi_name = dplyr::case_when(\r\n        act_date == \"2020-06-21\" ~ \"Albstadt\",\r\n        act_date == \"2020-06-22\" ~ \"Winterthur\",\r\n        act_date == \"2020-06-23\" ~ \"Flüelen\",\r\n        act_date == \"2020-06-24\" ~ \"Andermatt\",\r\n        act_date == \"2020-06-25\" ~ \"Lugano\",\r\n        TRUE ~ NA_character_)) %>%\r\n    dplyr::rename(lon = lng)\r\n}\r\n\r\n\r\n\r\n\r\n\r\ndf_poi <- extract_poi(sf_act_meas)\r\n\r\n\r\n\r\nVisualisation\r\nAltitude\r\nVisualise the altitude data:\r\n\r\n\r\n#' Visualise the altitude by using a ridge plot.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return ggplot of altitude data\r\n#' @export\r\n#'\r\n#' @examples\r\nvis_altitude_ridge <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    tibble::as_tibble() %>%\r\n    tidyr::unnest_legacy(act_data) %>%\r\n    dplyr::mutate(distance = distance / 1000) %>%\r\n    ggplot2::ggplot(ggplot2::aes(\r\n      x = distance, y = act_date_chr, height = altitude,\r\n      group = act_date_chr, color = act_date_chr)) +\r\n    ggridges::geom_ridgeline(scale = 0.0025, alpha = 0.2) +\r\n    ggplot2::labs(\r\n      x = \"Distance [km]\", y = ggplot2::element_blank()) +\r\n    ggplot2::theme_light() +\r\n    ggplot2::theme(\r\n      legend.position = \"none\") +\r\n    ggplot2::scale_y_discrete(position = \"right\") +\r\n    ggplot2::scale_x_continuous(breaks = scales::breaks_width(10))\r\n}\r\n\r\n\r\n\r\nThe function mainly applies the ggridges::geom_ridgeline function to the data. A form of visualisation that I’ve already used a lot. Its style is reminiscent of the famous Joy Division album cover.\r\n\r\n\r\ngg_altitude_ridges <- vis_altitude_ridge(sf_act_meas)\r\n\r\n\r\n\r\n\r\n\r\n\r\nSpatial Data\r\nDetermine the map data for all the activities. Use the ggmap::get_stamenmap function to download the data. The bounding box is calculated from the sf_act_meas object.\r\n\r\n\r\n#' Get the ground map for the visualisation of the spatial data.\r\n#'\r\n#' @param sf_act_meas\r\n#' @param tol_bbox\r\n#' @param map_zoom\r\n#'\r\n#' @return\r\n#' @export\r\n#'\r\n#' @examples\r\nget_alpen_map <- function(sf_act_meas, tol_bbox = 0.015, map_zoom = 10) {\r\n  bbox <- sf::st_bbox(sf_act_meas)\r\n\r\n  stamen_map <- ggmap::get_stamenmap(\r\n    bbox = c(\r\n      left = bbox$xmin[[1]] - tol_bbox,\r\n      right = bbox$xmax[[1]] + tol_bbox,\r\n      bottom = bbox$ymin[[1]] - tol_bbox,\r\n      top = bbox$ymax[[1]] + tol_bbox),\r\n    maptype = \"terrain-background\", zoom = map_zoom, color = \"bw\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\ngg_alpen <- get_alpen_map(sf_act_meas, tol_bbox = 0.1, map_zoom = 9)\r\n\r\n\r\n\r\n\r\n\r\n\r\nPlot the activity and the point of interest data onto the map. Use the ggrepel package to plot the labels of the points of interest. This avoids too much overplotting.\r\n\r\n\r\n#' Plot the spatial data (route + point of interest) onto the map\r\n#'\r\n#' @param sf_act_meas\r\n#' @param gg_alpen\r\n#'\r\n#' @return ggplot of spatial data\r\n#' @export\r\n#'\r\n#' @examples\r\nvis_ride <- function(sf_act_meas, gg_alpen, df_poi) {\r\n  ggmap::ggmap(gg_alpen) +\r\n    ggplot2::geom_sf(\r\n      data = sf_act_meas, inherit.aes = FALSE,\r\n      mapping = aes(color = act_date_chr), size = 1.2) +\r\n    ggrepel::geom_label_repel(\r\n      data = df_poi, mapping = aes(label = poi_name), alpha = 0.6,\r\n      family = \"Fira Code Retina\", size = 2.5) +\r\n    ggplot2::theme_light() +\r\n    ggplot2::labs(\r\n      x = \"Longitude\", y = \"Latitude\") +\r\n    ggplot2::theme(legend.position = \"none\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\ngg_rides <- vis_ride(sf_act_meas, gg_alpen_map, df_poi)\r\n\r\n\r\n\r\n\r\n\r\n\r\nCombine Visualisations\r\nCombine everything into one big plot using the patchwork package:\r\n\r\n\r\n# extrafont::font_import()\r\nextrafont::loadfonts(device = \"win\")\r\n\r\nfinal_plot <- (gg_rides + gg_altitude_ridges) +\r\n      plot_annotation(\r\n        title = \"Transalp 2020\",\r\n        subtitle = \"Albstadt - Lugano\") &\r\n      theme(text = element_text(family = \"Fira Code Retina\"))\r\n\r\nfinal_plot\r\n\r\n\r\n\r\n\r\nThe extrafont package helps with using some fancy fonts. The font_import function has to be called once. Comment the function call in the above code chunk because of this.\r\n\r\n\r\n\r\n",
    "preview": "posts/transalp/distill-preview.png",
    "last_modified": "2021-05-23T20:22:01+02:00",
    "input_file": {}
  }
]
