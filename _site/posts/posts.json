[
  {
    "path": "posts/transalp/",
    "title": "Getting Over It",
    "description": "Visualising my Transalp bike ride",
    "author": [
      {
        "name": "Julian During",
        "url": "www.datannery.com"
      }
    ],
    "date": "2021-05-23",
    "categories": [],
    "contents": "\r\nThis summer I crossed the alps with my road bike. I’ve recorded the whole ride and as a nice memory, I would like to visualise this ride.\r\nA short time ago I’ve discovered the awesome R package drake. The use of this package transformed the way I do my analysis and it helps me to make my post more reproducible. The following blog post describes the underlying workflow, after which I’ve developed the underlying package transalp for this post.\r\nData\r\nAt first you have to install the package from github. Then you have to load it.\r\n\r\n\r\nremotes::install_github(\"duju211/transalp\")\r\n\r\nlibrary(transalp)\r\n\r\n\r\n\r\nLoad the other necessary libraries:\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(patchwork)\r\nlibrary(drake)\r\nlibrary(here)\r\nlibrary(fs)\r\n\r\n\r\n\r\nThe package includes the underlying data:\r\n\r\n\r\ndf_act_meas_raw <- transalp::df_act_meas\r\n\r\n\r\n\r\n\r\n# A tibble: 90,917 x 10\r\n   id         act_date   moving velocity_smooth grade_smooth distance\r\n   <chr>      <date>     <lgl>            <dbl>        <dbl>    <dbl>\r\n 1 3669729902 2020-06-25 FALSE              0            0        0  \r\n 2 3669729902 2020-06-25 FALSE              0            0        0.9\r\n 3 3669729902 2020-06-25 TRUE               0          -44.6      4.6\r\n 4 3669729902 2020-06-25 TRUE               0            1.4      8.4\r\n 5 3669729902 2020-06-25 TRUE               0            2.8     12.1\r\n 6 3669729902 2020-06-25 TRUE               0            2.8     15.6\r\n 7 3669729902 2020-06-25 TRUE               0            1.4     19.1\r\n 8 3669729902 2020-06-25 TRUE               3.6          1.4     22.5\r\n 9 3669729902 2020-06-25 TRUE               3.5          0       26  \r\n10 3669729902 2020-06-25 TRUE               3.5          1.6     29.5\r\n# ... with 90,907 more rows, and 4 more variables: altitude <dbl>,\r\n#   time <int>, lat <dbl>, lng <dbl>\r\n\r\nPreprocessing\r\nLook at the first function:\r\n\r\n\r\n#' Function to preprocess measurements of the included activities.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return Preprocessed activities\r\n#' @export\r\n#'\r\n#' @examples\r\n#' pre_process_meas(df_act_meas)\r\npre_process_meas <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    dplyr::mutate(\r\n      act_date_chr = as.character(act_date),\r\n      altitude_norm = altitude / max(altitude)) %>%\r\n    dplyr::group_by(id) %>%\r\n    dplyr::mutate(distance_norm = distance / max(distance)) %>%\r\n    dplyr::ungroup()\r\n}\r\n\r\n\r\n\r\nThe function does some basic preprocessing on the included activities:\r\nTurn activity date into character (for easier plotting)\r\nNormalize altitude and distance\r\n\r\n\r\ndf_act_meas <- pre_process_meas(df_act_meas_raw)\r\n\r\n\r\n\r\nNest the data frame by id and act_date_chr. Create a new sf column with the geospatial information of the activities:\r\n\r\n\r\n#' Turn every activity into an sf object. Nest the data frame by 'id' and\r\n#' 'act_date_chr' to do this.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return sf object\r\n#' @export\r\n#'\r\n#' @examples\r\nconvert_to_sf <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    tidyr::nest(act_data = -c(id, act_date_chr)) %>%\r\n    dplyr::mutate(\r\n      line = purrr::map(\r\n        act_data,\r\n        ~ sf::st_linestring(as.matrix(.x[, c(\"lng\", \"lat\", \"altitude\")]))),\r\n      geom = purrr::map(line, sf::st_sfc, crs = 4326)) %>%\r\n    sf::st_as_sf()\r\n}\r\n\r\n\r\n\r\n\r\n\r\nsf_act_meas <- convert_to_sf(df_act_meas)\r\n\r\n\r\n\r\n\r\nSimple feature collection with 5 features and 4 fields\r\nGeometry type: LINESTRING\r\nDimension:     XYZ\r\nBounding box:  xmin: 8.317612 ymin: 46.0061 xmax: 9.035269 ymax: 48.21307\r\nz_range:       zmin: 206.8 zmax: 2477.6\r\nCRS:           NA\r\n# A tibble: 5 x 5\r\n  id     act_date_chr act_data                             line geom  \r\n  <chr>  <chr>        <list>                       <LINESTRING> <list>\r\n1 36697~ 2020-06-25   <tibble [~ Z (8.596761 46.63501 1451.6, ~ <LINE~\r\n2 36646~ 2020-06-24   <tibble [~ Z (8.602206 46.63612 1510.2, ~ <LINE~\r\n3 36590~ 2020-06-23   <tibble [~ Z (8.625703 46.90152 447, 8.6~ <LINE~\r\n4 36542~ 2020-06-22   <tibble [~ Z (8.741265 47.49397 432, 8.7~ <LINE~\r\n5 36504~ 2020-06-21   <tibble [~ Z (9.021049 48.21307 750.2, 9~ <LINE~\r\n\r\nExtract the start point of every tour except for the last one. Extract the end point for this tour.\r\n\r\n\r\n#' Extract points of interest.\r\n#'\r\n#' @param sf_act_meas\r\n#'\r\n#' @return Data frame with points of interest\r\n#' @export\r\n#'\r\n#' @examples\r\nextract_poi <- function(sf_act_meas) {\r\n  sf_act_meas %>%\r\n    tibble::as_tibble() %>%\r\n    dplyr::transmute(\r\n      id, first_row = purrr::map(act_data, ~ .x[1,]),\r\n      last_row = purrr::map(act_data, ~ .x[nrow(.x), ]),\r\n      decisive_row = dplyr::if_else(id == \"3669729902\", last_row, first_row)) %>%\r\n    tidyr::unnest(decisive_row) %>%\r\n    dplyr::select(where(purrr::negate(purrr::is_list))) %>%\r\n    dplyr::mutate(\r\n      poi_name = dplyr::case_when(\r\n        act_date == \"2020-06-21\" ~ \"Albstadt\",\r\n        act_date == \"2020-06-22\" ~ \"Winterthur\",\r\n        act_date == \"2020-06-23\" ~ \"Flüelen\",\r\n        act_date == \"2020-06-24\" ~ \"Andermatt\",\r\n        act_date == \"2020-06-25\" ~ \"Lugano\",\r\n        TRUE ~ NA_character_)) %>%\r\n    dplyr::rename(lon = lng)\r\n}\r\n\r\n\r\n\r\n\r\n\r\ndf_poi <- extract_poi(sf_act_meas)\r\n\r\n\r\n\r\nVisualisation\r\nAltitude\r\nVisualise the altitude data:\r\n\r\n\r\n#' Visualise the altitude by using a ridge plot.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return ggplot of altitude data\r\n#' @export\r\n#'\r\n#' @examples\r\nvis_altitude_ridge <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    tibble::as_tibble() %>%\r\n    tidyr::unnest_legacy(act_data) %>%\r\n    dplyr::mutate(distance = distance / 1000) %>%\r\n    ggplot2::ggplot(ggplot2::aes(\r\n      x = distance, y = act_date_chr, height = altitude,\r\n      group = act_date_chr, color = act_date_chr)) +\r\n    ggridges::geom_ridgeline(scale = 0.0025, alpha = 0.2) +\r\n    ggplot2::labs(\r\n      x = \"Distance [km]\", y = ggplot2::element_blank()) +\r\n    ggplot2::theme_light() +\r\n    ggplot2::theme(\r\n      legend.position = \"none\") +\r\n    ggplot2::scale_y_discrete(position = \"right\") +\r\n    ggplot2::scale_x_continuous(breaks = scales::breaks_width(10))\r\n}\r\n\r\n\r\n\r\nThe function mainly applies the ggridges::geom_ridgeline function to the data. A form of visualisation that I’ve already used a lot. Its style is reminiscent of the famous Joy Division album cover.\r\n\r\n\r\ngg_altitude_ridges <- vis_altitude_ridge(sf_act_meas)\r\n\r\n\r\n\r\n\r\n\r\n\r\nSpatial Data\r\nDetermine the map data for all the activities. Use the ggmap::get_stamenmap function to download the data. The bounding box is calculated from the sf_act_meas object.\r\n\r\n\r\n#' Get the ground map for the visualisation of the spatial data.\r\n#'\r\n#' @param sf_act_meas\r\n#' @param tol_bbox\r\n#' @param map_zoom\r\n#'\r\n#' @return\r\n#' @export\r\n#'\r\n#' @examples\r\nget_alpen_map <- function(sf_act_meas, tol_bbox = 0.015, map_zoom = 10) {\r\n  bbox <- sf::st_bbox(sf_act_meas)\r\n\r\n  stamen_map <- ggmap::get_stamenmap(\r\n    bbox = c(\r\n      left = bbox$xmin[[1]] - tol_bbox,\r\n      right = bbox$xmax[[1]] + tol_bbox,\r\n      bottom = bbox$ymin[[1]] - tol_bbox,\r\n      top = bbox$ymax[[1]] + tol_bbox),\r\n    maptype = \"terrain-background\", zoom = map_zoom, color = \"bw\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\ngg_alpen <- get_alpen_map(sf_act_meas, tol_bbox = 0.1, map_zoom = 9)\r\n\r\n\r\n\r\n\r\n\r\n\r\nPlot the activity and the point of interest data onto the map. Use the ggrepel package to plot the labels of the points of interest. This avoids too much overplotting.\r\n\r\n\r\n#' Plot the spatial data (route + point of interest) onto the map\r\n#'\r\n#' @param sf_act_meas\r\n#' @param gg_alpen\r\n#'\r\n#' @return ggplot of spatial data\r\n#' @export\r\n#'\r\n#' @examples\r\nvis_ride <- function(sf_act_meas, gg_alpen, df_poi) {\r\n  ggmap::ggmap(gg_alpen) +\r\n    ggplot2::geom_sf(\r\n      data = sf_act_meas, inherit.aes = FALSE,\r\n      mapping = aes(color = act_date_chr), size = 1.2) +\r\n    ggrepel::geom_label_repel(\r\n      data = df_poi, mapping = aes(label = poi_name), alpha = 0.6,\r\n      family = \"Fira Code Retina\", size = 2.5) +\r\n    ggplot2::theme_light() +\r\n    ggplot2::labs(\r\n      x = \"Longitude\", y = \"Latitude\") +\r\n    ggplot2::theme(legend.position = \"none\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\ngg_rides <- vis_ride(sf_act_meas, gg_alpen_map, df_poi)\r\n\r\n\r\n\r\n\r\n\r\n\r\nCombine Visualisations\r\nCombine everything into one big plot using the patchwork package:\r\n\r\n\r\n# extrafont::font_import()\r\nextrafont::loadfonts(device = \"win\")\r\n\r\nfinal_plot <- (gg_rides + gg_altitude_ridges) +\r\n      plot_annotation(\r\n        title = \"Transalp 2020\",\r\n        subtitle = \"Albstadt - Lugano\") &\r\n      theme(text = element_text(family = \"Fira Code Retina\"))\r\n\r\nfinal_plot\r\n\r\n\r\n\r\n\r\nThe extrafont package helps with using some fancy fonts. The font_import function has to be called once. Comment the function call in the above code chunk because of this.\r\n\r\n\r\n\r\n",
    "preview": "posts/transalp/distill-preview.png",
    "last_modified": "2021-05-23T17:31:41+02:00",
    "input_file": {}
  },
  {
    "path": "posts/scrape_strava/",
    "title": "Strava Data",
    "description": "Arcticle on how to effectively scrape and store Strava data",
    "author": [
      {
        "name": "Julian During",
        "url": "www.datannery.com"
      }
    ],
    "date": "2021-05-17",
    "categories": [],
    "contents": "\r\nI am a vivid runner and cyclist. Since a few years, I’m recording almost all my activities with some kind of GPS device.\r\nI record my runs with a Garmin device and my bike rides with a Wahoo device. Both accounts get synchronized with my Strava account. I figured that it would be nice to directly access my data from my Strava account.\r\nIn the following text, I will describe the progress to get the data into R. Once available in a nice format in R, the data is stored as a pin in a private github repository. By doing so, the data is easily accessible in other analysis or shiny apps.\r\nIn this analysis, the following packages are used:\r\n\r\n\r\nlibrary(conflicted)\r\nlibrary(tidyverse)\r\nlibrary(lubridate)\r\nlibrary(drake)\r\nlibrary(pins)\r\nlibrary(rava)\r\nlibrary(httr)\r\nlibrary(fs)\r\n\r\nconflict_prefer(\"filter\", \"dplyr\")\r\n\r\n\r\n\r\nThe rava package is a package with helper functions regarding Strava data. It can be installed via the following command:\r\n\r\n\r\nremotes::install_github(\"duju211/rava\")\r\n\r\n\r\n\r\nData\r\nTo get access to your Strava data from R, you have to create a Strava api. How to do this is documented here.\r\nOAuth Dance from R\r\nThe Strava api requires a so called OAuth dance. How this can be done from within R is described in the following section.\r\nCreate an OAuth Strava app:\r\n\r\n\r\ndefine_strava_app <- function() {\r\n  httr::oauth_app(\r\n    appname = \"r_api\",\r\n    key = Sys.getenv(\"STRAVA_KEY\"),\r\n    secret = Sys.getenv(\"STRAVA_SECRET\"))\r\n}\r\n\r\n\r\n\r\nYou can find your STRAVA_KEY and STRAVA_SECRET variables under the Strava api settings after you have created your own personal api. The name of api is determined during creation. In my case I named it r_api.\r\n\r\n\r\nmy_app <- define_strava_app()\r\n\r\n\r\n\r\nDefine an endpoint:\r\n\r\n\r\ndefine_strava_endpoint <- function() {\r\n  httr::oauth_endpoint(\r\n    request = NULL,\r\n    authorize = \"https://www.strava.com/oauth/authorize\",\r\n    access = \"https://www.strava.com/oauth/token\")\r\n}\r\n\r\n\r\n\r\nThe authorize parameter describes the url to send client to for authorization. And the access argument is used to exchange the authenticated token.\r\n\r\n\r\nmy_endpoint <- define_strava_endpoint()\r\n\r\n\r\n\r\nThe final authentication step. Before the user can execute the following steps, he has to authenticate the api in the web browser.\r\n\r\n\r\ndefine_strava_sig <- function(endpoint, app) {\r\n  httr::oauth2.0_token(\r\n    endpoint, app,\r\n    scope = \"activity:read_all,activity:read,profile:read_all\",\r\n    type = NULL, use_oob = FALSE, as_header = FALSE,\r\n    use_basic_auth = FALSE, cache = FALSE)\r\n}\r\n\r\n\r\n\r\n\r\n\r\nmy_sig <- define_strava_sig(my_app, my_endpoint)\r\n\r\n\r\n\r\nThe information in my_sig can now be used to access Strava data.\r\nActivities\r\nWe are now authenticated and can directly access Strava data. At first load an overview table of all available activities (one activity per row). Because the total number of activities is unknown, use a while loop. Break the execution of the loop, if there are no more activities to read.\r\n\r\n\r\nread_all_activities <- function(sig) {\r\n  activities_url <- httr::parse_url(\r\n    \"https://www.strava.com/api/v3/athlete/activities\")\r\n\r\n  act_vec <- vector(mode = \"list\")\r\n  df_act <- tibble::tibble(init = \"init\")\r\n  i <- 1L\r\n\r\n  while (nrow(df_act) != 0) {\r\n    r <- activities_url %>%\r\n      httr::modify_url(\r\n        query = list(\r\n          access_token = sig$credentials$access_token[[1]],\r\n          page = i)) %>%\r\n      httr::GET()\r\n\r\n    df_act <- httr::content(r, as = \"text\") %>%\r\n      jsonlite::fromJSON(flatten = TRUE) %>%\r\n      tibble::as_tibble()\r\n    if (nrow(df_act) != 0)\r\n      act_vec[[i]] <- df_act\r\n    i <- i + 1L\r\n  }\r\n\r\n  df_activities <- act_vec %>%\r\n    dplyr::bind_rows() %>%\r\n    dplyr::mutate(start_date = lubridate::ymd_hms(start_date))\r\n}\r\n\r\n\r\n\r\n\r\n\r\ndf_act_raw <- read_all_activities(my_sig)\r\ndf_act_raw\r\n\r\n\r\n\r\n\r\n# A tibble: 553 x 60\r\n   resource_state name               distance moving_time elapsed_time\r\n            <int> <chr>                 <dbl>       <int>        <int>\r\n 1              2 \"Run-Before-The-E~    8446.        3765         3936\r\n 2              2 \"Saturday Breakfa~    9145.        3591         3801\r\n 3              2 \"Pidcock Trail \"      8780.        3603         3667\r\n 4              2 \"Lauf am Nachmitt~    7194.        3022         3189\r\n 5              2 \"Sunny Forest Run\"   11317         4559         4826\r\n 6              2 \"Bear Valley Clim~   61372.        9817        11848\r\n 7              2 \"Fahrt am Nachmit~   42834.        7072         7812\r\n 8              2 \"Coffee Run\"          3846.        1549         1549\r\n 9              2 \"Sunday Runday\"       8394.        3651         3787\r\n10              2 \"Hay Mountain Run~    9190.        3584         3853\r\n# ... with 543 more rows, and 55 more variables:\r\n#   total_elevation_gain <dbl>, type <chr>, workout_type <int>,\r\n#   id <dbl>, external_id <chr>, upload_id <dbl>, start_date <dttm>,\r\n#   start_date_local <chr>, timezone <chr>, utc_offset <dbl>,\r\n#   start_latlng <list>, end_latlng <list>, location_city <lgl>,\r\n#   location_state <lgl>, location_country <chr>,\r\n#   start_latitude <dbl>, start_longitude <dbl>,\r\n#   achievement_count <int>, kudos_count <int>, comment_count <int>,\r\n#   athlete_count <int>, photo_count <int>, trainer <lgl>,\r\n#   commute <lgl>, manual <lgl>, private <lgl>, visibility <chr>,\r\n#   flagged <lgl>, gear_id <chr>, from_accepted_tag <lgl>,\r\n#   upload_id_str <chr>, average_speed <dbl>, max_speed <dbl>,\r\n#   has_heartrate <lgl>, heartrate_opt_out <lgl>,\r\n#   display_hide_heartrate_option <lgl>, elev_high <dbl>,\r\n#   elev_low <dbl>, pr_count <int>, total_photo_count <int>,\r\n#   has_kudoed <lgl>, average_cadence <dbl>, average_heartrate <dbl>,\r\n#   max_heartrate <dbl>, average_temp <int>, device_watts <lgl>,\r\n#   average_watts <dbl>, weighted_average_watts <int>,\r\n#   kilojoules <dbl>, max_watts <int>, athlete.id <int>,\r\n#   athlete.resource_state <int>, map.id <chr>,\r\n#   map.summary_polyline <chr>, map.resource_state <int>\r\n\r\nDetermine activities, that were already scraped:\r\n\r\n\r\nexisting_activities <- function(board_name) {\r\n  board_register_github(repo = board_name, name = \"strava_act\")\r\n\r\n  df_all_pins_raw <- pin_find(board = \"strava_act\")\r\n\r\n  df_all_pins <- df_all_pins_raw %>%\r\n    distinct(name) %>%\r\n    filter(str_detect(name, \"^act\")) %>%\r\n    mutate(name = str_remove(name, \"^act_\")) %>%\r\n    separate(col = name, into = c(\"id\", \"athlete.id\"))\r\n\r\n  board_disconnect(\"strava_act\")\r\n\r\n  return(df_all_pins)\r\n}\r\n\r\n\r\n\r\n\r\n\r\ndf_existing_act <- existing_activities(board_name)\r\n\r\n\r\n\r\nPin all activities to a private github repository:\r\n\r\n\r\npin_new_activities <- function(df_act) {\r\n  board_register_github(\r\n    repo = \"duju211/strava_act\", name = \"strava_act\", branch = \"master\")\r\n\r\n  pin(df_act, \"df_act\", board = \"strava_act\")\r\n\r\n  board_disconnect(\"strava_act\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\npin_new_activities(df_act)\r\n\r\n\r\n\r\nMeasurements\r\nRead the ‘stream’ data from Strava. A ‘stream’ is a nested list (json format) with all available measurements of the corresponding activity.\r\nTo get all available variables and turn the result into a data frame, define a helper function. This function takes an id of an activity and an authentication token, which we have created earlier.\r\n\r\n\r\nread_activity_stream <- function(id, sig) {\r\n  act_url <- httr::parse_url(stringr::str_glue(\r\n    \"https://www.strava.com/api/v3/activities/{id}/streams\"))\r\n  access_token <- sig$credentials$access_token[[1]]\r\n\r\n  r <- httr::modify_url(\r\n    act_url,\r\n    query = list(\r\n      access_token = access_token,\r\n      keys = stringr::str_glue(\r\n        \"distance,time,latlng,altitude,velocity_smooth,heartrate,cadence,watts,\r\n        temp,moving,grade_smooth\"))) %>%\r\n    httr::GET()\r\n\r\n  jsonlite::fromJSON(httr::content(r, as = \"text\"), flatten = TRUE) %>%\r\n    tibble::as_tibble()\r\n}\r\n\r\n\r\n\r\nExtract the measurements for each new activity and pin the result to the repository:\r\n\r\n\r\npin_new_rides <- function(df_act, df_existing_act, my_sig, board_name) {\r\n  df_act_new <- df_act %>%\r\n    anti_join(df_existing_act, by = c(\"id\", \"athlete.id\"))\r\n\r\n  df_meas <- df_act_new %>%\r\n    transmute(\r\n      id, `athlete.id`,\r\n      stream = map(id, ~ read_activity_stream(id = .x, sig = my_sig))) %>%\r\n    tidy_streams() %>%\r\n    unnest(stream) %>%\r\n    select(id, `athlete.id`, where(is_list)) %>%\r\n    unnest(where(purrr::is_list))\r\n\r\n  df_meas_nested <- df_meas %>%\r\n    nest(meas = -c(id, `athlete.id`))\r\n\r\n  board_register_github(repo = board_name, name = board_name, branch = \"master\")\r\n\r\n  pwalk(\r\n    list(\r\n      m = df_meas_nested$meas, id = df_meas_nested$id,\r\n      a_id = df_meas_nested$`athlete.id`),\r\n    function(m, id, a_id)\r\n      pin(m, str_glue(\"act_{id}_{a_id}\"), board = board_name))\r\n\r\n  board_disconnect(board_name)\r\n}\r\n\r\n\r\n\r\nDownload all measurement data from the repository and combine in one big data frame:\r\n\r\n\r\nact_meas <- function(board_name, pin_result) {\r\n  board_register_github(repo = board_name, name = board_name, branch = \"master\")\r\n\r\n  df_act_meas_nested <- pin_find(board = board_name) %>%\r\n    filter(str_detect(name, \"^act\")) %>%\r\n    mutate(meas = map(name, ~ pin_get(name = .x, board = board_name)))\r\n\r\n  df_act_meas <- df_act_meas_nested %>%\r\n    select(name, meas) %>%\r\n    filter(map_lgl(meas, ~ is_tibble(.x))) %>%\r\n    unnest(meas)\r\n\r\n  board_disconnect(board_name)\r\n\r\n  df_act_meas\r\n}\r\n\r\n\r\n\r\n\r\n\r\ndf_act_meas_nested <- read_meas_nested(df_act_ids)\r\ndf_act_meas <- unnest(df_act_meas_nested, meas)\r\ndf_act_meas\r\n\r\n\r\n\r\n\r\n\r\ndf_act_meas %>%\r\n  select(-name)\r\n\r\n\r\n# A tibble: 1,953,631 x 11\r\n   moving velocity_smooth grade_smooth distance altitude  time   lat\r\n   <lgl>            <dbl>        <dbl>    <dbl>    <dbl> <int> <dbl>\r\n 1 FALSE              0            0        0       746      0  48.2\r\n 2 TRUE               1.8         -0.3     40.7     746     23  48.2\r\n 3 TRUE               2.1         -3.2     54.7     746     26  48.2\r\n 4 TRUE               7.2         -5.4    120.      746.    34  48.2\r\n 5 TRUE               8.9         -6      188.      740.    41  48.2\r\n 6 TRUE               5           -7.6    249.      735.    60  48.2\r\n 7 TRUE               2.8         -7.1    262.      734.    68  48.2\r\n 8 TRUE               4.5         -6.3    329.      730.    78  48.2\r\n 9 TRUE               5.7         -5.2    359.      728.    85  48.2\r\n10 TRUE               4.1         -1      366.      727.    87  48.2\r\n# ... with 1,953,621 more rows, and 4 more variables: lng <dbl>,\r\n#   heartrate <int>, cadence <int>, watts <int>\r\n\r\nVisualisation\r\nVisualize the final data. Every facet is a activity and the color represents the type.\r\n\r\n\r\ndf_act_meas %>%\r\n  filter(!is.na(lat)) %>%\r\n  ggplot(aes(x = lng, y = lat)) +\r\n    geom_path() +\r\n    facet_wrap(~ name, scales = \"free\") +\r\n    theme(\r\n      axis.line = element_blank(),\r\n      axis.text.x = element_blank(),\r\n      axis.text.y = element_blank(),\r\n      axis.ticks = element_blank(),\r\n      axis.title.x = element_blank(),\r\n      axis.title.y = element_blank(),\r\n      legend.position = \"bottom\",\r\n      panel.background = element_blank(),\r\n      panel.border = element_blank(),\r\n      panel.grid.major = element_blank(),\r\n      panel.grid.minor = element_blank(),\r\n      plot.background = element_blank(),\r\n      strip.text = element_blank())\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/scrape_strava/distill-preview.png",
    "last_modified": "2021-05-17T20:35:48+02:00",
    "input_file": {}
  },
  {
    "path": "posts/hex_sticker/",
    "title": "Hex Sticker",
    "description": "How to create a hex sticker for a new package",
    "author": [
      {
        "name": "Julian During",
        "url": "https://twitter.com/OACantona"
      }
    ],
    "date": "2021-05-16",
    "categories": [],
    "contents": "\r\nIn this post, I want to describe how I created a hex sticker for one of my shiny apps. The app itself lets users interactively explore their Strava data.\r\nBecause I called the app SummitR, I decided to display one of the most famous summit finishes in cycling history: Alpe d’Huez.\r\nI am using the following packages:\r\n\r\n\r\nlibrary(hexSticker)\r\nlibrary(tidyverse)\r\nlibrary(pins)\r\n\r\n\r\n\r\nThe hexSticker package is used to create the final sticker.\r\nBecause I already climbed Alpe d’Huez on a previous occasion, I can get the data already prepared from a private github repository. The data in the corresponding repository is organised as a pin:\r\n\r\n\r\nalpe_dhuez_id <- \"1714646144\"\r\nathlete_id <- \"26845822\"\r\n\r\nboard_register_github(repo = \"duju211/strava_act\", branch = \"master\")\r\n\r\ndf_act <- pin_get(\r\n  str_glue(\"act_{alpe_dhuez_id}_{athlete_id}\"), board = \"github\")\r\n\r\nboard_disconnect(\"github\")\r\n\r\n\r\n\r\nIn raw table form the data of the activity looks like this:\r\n\r\n# A tibble: 5,326 x 11\r\n   moving velocity_smooth grade_smooth distance altitude  time   lat\r\n   <lgl>            <dbl>        <dbl>    <dbl>    <dbl> <int> <dbl>\r\n 1 FALSE              0            8.6      0       787      0  45.1\r\n 2 TRUE               0            8.6      2.1     787.     1  45.1\r\n 3 TRUE               2.3          8.6      4.5     787.     2  45.1\r\n 4 TRUE               2.3         10        7       788.     3  45.1\r\n 5 TRUE               2.3         11.9      9.3     788.     4  45.1\r\n 6 TRUE               2.3         12       11.6     788      5  45.1\r\n 7 TRUE               2.4         11.9     14.1     788.     6  45.1\r\n 8 TRUE               2.4         13.6     16.3     789.     7  45.1\r\n 9 TRUE               2.3         12       18.7     789      8  45.1\r\n10 TRUE               2.4         12.6     21.1     789.     9  45.1\r\n# ... with 5,316 more rows, and 4 more variables: lng <dbl>,\r\n#   heartrate <int>, cadence <int>, watts <int>\r\n\r\nCreate a minimalistic plot of the activity. Only take variables lat and lng into account:\r\n\r\n\r\ngg_act <- df_act %>% \r\n  ggplot(aes(x = lng, y = lat)) +\r\n  geom_path(color = \"white\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\nPlot the path of the activity on a black background:\r\n\r\n\r\ngg_act +\r\n  theme_dark()\r\n\r\n\r\n\r\n\r\nSave the finished hex sticker as result. Use the official Strava color as background color.\r\n\r\n\r\nsticker(\r\n  gg_act, package=\"SummitR\", p_size=20, s_x=1.1, s_y=.75, s_width=1.3,\r\n  s_height=1, h_fill = \"#fc4c02\", h_color = \"white\",\r\n  filename=\"_posts/hex_sticker/hex_sticker.png\")\r\n\r\n\r\n\r\n\r\n\r\nknitr::include_graphics(\"hex_sticker.png\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/hex_sticker/distill-preview.png",
    "last_modified": "2021-05-16T18:20:26+02:00",
    "input_file": {}
  }
]
