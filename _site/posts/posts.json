[
  {
    "path": "posts/strava-data/",
    "title": "Strava Data",
    "description": "Article on how to effectively scrape and store Strava data using the `targets`\npackage",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-11-22",
    "categories": [],
    "contents": "\r\nI am a vivid runner and cyclist. Since a couple of years, I’m recording almost all my activities with some kind of GPS device.\r\nI record my runs with a Garmin device and my bike rides with a Wahoo device. Both accounts get synchronized with my Strava account. I figured that it would be nice to directly access my data from my Strava account.\r\nIn the following text, I will describe the progress to get the data into R.\r\nIn this analysis, the following packages are used:\r\n\r\n\r\nlibrary(tarchetypes)\r\nlibrary(conflicted)\r\nlibrary(tidyverse)\r\nlibrary(lubridate)\r\nlibrary(jsonlite)\r\nlibrary(targets)\r\nlibrary(httpuv)\r\nlibrary(httr)\r\nlibrary(pins)\r\nlibrary(httr)\r\nlibrary(fs)\r\n\r\nconflict_prefer(\"filter\", \"dplyr\")\r\n\r\n\r\n\r\nData\r\nThe whole data pipeline is implemented with the help of the targets package. Here you can learn more about the package and its functionalities.\r\nTarget Plan\r\nThe manifest of the target plan looks like this:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\nmy_app\r\ndefine_strava_app()\r\nNA\r\nthorough\r\nmy_endpoint\r\ndefine_strava_endpoint()\r\nNA\r\nthorough\r\nact_col_types\r\nlist(moving = col_logical(), velocity_smooth = col_number(), grade_smooth = col_number(), distance = col_number(), altitude = col_number(), heartrate = col_integer(), time = col_integer(), lat = col_number(), lng = col_number(), cadence = col_integer(), watts = col_integer())\r\nNA\r\nthorough\r\nmy_sig\r\ndefine_strava_sig(my_endpoint, my_app)\r\nNA\r\nalways\r\ndf_act_raw\r\nread_all_activities(my_sig)\r\nNA\r\nthorough\r\ndf_act\r\npre_process_act(df_act_raw, athlete_id)\r\nNA\r\nthorough\r\nact_ids\r\npull(distinct(df_act, id))\r\nNA\r\nthorough\r\ndf_meas\r\nread_activity_stream(act_ids, my_sig)\r\nmap(act_ids)\r\nnever\r\ndf_meas_all\r\nbind_rows(df_meas)\r\nNA\r\nthorough\r\ndf_meas_wide\r\nmeas_wide(df_meas_all)\r\nNA\r\nthorough\r\ndf_meas_pro\r\nmeas_pro(df_meas_wide)\r\nNA\r\nthorough\r\ndf_meas_rel\r\nmeas_rel(df_act, df_meas_pro)\r\nNA\r\nthorough\r\ndf_meas_norm\r\nmeas_norm(df_meas_pro)\r\nNA\r\nthorough\r\ngg_meas\r\nvis_meas(df_meas_rel)\r\nNA\r\nthorough\r\ngg_meas_save\r\nsave_gg_meas(gg_meas)\r\nNA\r\nthorough\r\n\r\nThe most important targets of the plan are described in detail in the following subsections.\r\nOAuth Dance from R\r\nTo get access to your Strava data from R, you have to create a Strava api. How to do this is documented here.\r\nThe Strava api requires a so called OAuth dance. How this can be done from within R is described in the following section.\r\nCreate an OAuth Strava app:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\nmy_app\r\ndefine_strava_app()\r\nNA\r\nthorough\r\n\r\n\r\n\r\ndefine_strava_app <- function() {\r\n  if (Sys.getenv(\"STRAVA_KEY\") == \"\" | Sys.getenv(\"STRAVA_SECRET\") == \"\")\r\n    stop(str_glue(\r\n      \"Please set system variables 'STRAVA_KEY' and 'STRAVA_SECRET' before \",\r\n      \"continuing. How you can create these variables is described here: \",\r\n      \"https://developers.strava.com/docs/getting-started/. \",\r\n      \"You can set the system variables with the `usethis::edit_r_environ` \",\r\n      \"function.\"))\r\n\r\n  oauth_app(\r\n    appname = \"r_api\",\r\n    key = Sys.getenv(\"STRAVA_KEY\"),\r\n    secret = Sys.getenv(\"STRAVA_SECRET\"))\r\n}\r\n\r\n\r\n\r\nYou can find your STRAVA_KEY and STRAVA_SECRET variables under the Strava api settings after you have created your own personal api. The name of api is determined during creation. In my case I named it r_api.\r\nDefine an endpoint:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\nmy_endpoint\r\ndefine_strava_endpoint()\r\nNA\r\nthorough\r\n\r\n\r\n\r\ndefine_strava_endpoint <- function() {\r\n  oauth_endpoint(\r\n    request = NULL,\r\n    authorize = \"https://www.strava.com/oauth/authorize\",\r\n    access = \"https://www.strava.com/oauth/token\")\r\n}\r\n\r\n\r\n\r\nThe authorize parameter describes the authorization url. And the access argument is used to exchange the authenticated token.\r\nThe final authentication step. Before the user can execute the following steps, he has to authenticate the api in the web browser.\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\nmy_sig\r\ndefine_strava_sig(my_endpoint, my_app)\r\nNA\r\nalways\r\n\r\n\r\n\r\ndefine_strava_sig <- function(endpoint, app) {\r\n  oauth2.0_token(\r\n    endpoint, app,\r\n    scope = \"activity:read_all,activity:read,profile:read_all\",\r\n    type = NULL, use_oob = FALSE, as_header = FALSE,\r\n    use_basic_auth = FALSE, cache = FALSE)\r\n}\r\n\r\n\r\n\r\nThe information in my_sig can now be used to access Strava data. Set the cue_mode of the target to ‘always’, so that the user has to authenticate and the following api calls are all executed with an up to date authorization token.\r\nActivities\r\nWe are now authenticated and can directly access Strava data. At first load an overview table of all available activities. Because the total number of activities is unknown, use a while loop. Break the execution of the loop, if there are no more activities to read.\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ndf_act_raw\r\nread_all_activities(my_sig)\r\nNA\r\nthorough\r\n\r\n\r\n\r\nread_all_activities <- function(sig) {\r\n  activities_url <- parse_url(\r\n    \"https://www.strava.com/api/v3/athlete/activities\")\r\n\r\n  act_vec <- vector(mode = \"list\")\r\n  df_act <- tibble::tibble(init = \"init\")\r\n  i <- 1L\r\n\r\n  while (nrow(df_act) != 0) {\r\n    r <- activities_url %>%\r\n      modify_url(\r\n        query = list(\r\n          access_token = sig$credentials$access_token[[1]],\r\n          page = i)) %>%\r\n      GET()\r\n\r\n    df_act <- content(r, as = \"text\") %>%\r\n      fromJSON(flatten = TRUE) %>%\r\n      as_tibble()\r\n    if (nrow(df_act) != 0)\r\n      act_vec[[i]] <- df_act\r\n    i <- i + 1L\r\n  }\r\n\r\n  act_vec %>%\r\n    bind_rows() %>%\r\n    mutate(start_date = ymd_hms(start_date))\r\n}\r\n\r\n\r\n\r\nThe resulting data frame consists of one row per activity:\r\n\r\n# A tibble: 608 x 60\r\n   resource_state name               distance moving_time elapsed_time\r\n            <int> <chr>                 <dbl>       <int>        <int>\r\n 1              2 \"Holiday Start \\U~   48469.        8313         8619\r\n 2              2 \"Run of Prayer an~    6847.        2767         2785\r\n 3              2 \"Astoria After Ru~    5037.        2742         3314\r\n 4              2 \"Hessen Kassel Wa~   31153.        4699         5267\r\n 5              2 \"Bambi Run\"           5888.        2421         2869\r\n 6              2 \"Lindich Backward~   33208.        4909         6071\r\n 7              2 \"Monastery Ride\"     74154.       10721        12500\r\n 8              2 \"Chapeau Sprint \"    34380         5001         5388\r\n 9              2 \"Morning Run\"         5518.        2345         2563\r\n10              2 \"Binsenbol Afterw~   10022.        3681         6447\r\n# ... with 598 more rows, and 55 more variables:\r\n#   total_elevation_gain <dbl>, type <chr>, workout_type <int>,\r\n#   id <dbl>, external_id <chr>, upload_id <dbl>, start_date <dttm>,\r\n#   start_date_local <chr>, timezone <chr>, utc_offset <dbl>,\r\n#   start_latlng <list>, end_latlng <list>, location_city <lgl>,\r\n#   location_state <lgl>, location_country <chr>,\r\n#   start_latitude <dbl>, start_longitude <dbl>, ...\r\n\r\nPreprocess activities. Make sure that all id columns are represented as characters and improve the column names:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ndf_act\r\npre_process_act(df_act_raw, athlete_id)\r\nNA\r\nthorough\r\n\r\n\r\n\r\npre_process_act <- function(df_act_raw, athlete_id) {\r\n  df_act_raw %>%\r\n    mutate(across(contains(\"id\"), as.character)) %>%\r\n    rename(athlete_id = `athlete.id`)\r\n}\r\n\r\n\r\n\r\nExtract all ids of the activities:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\nact_ids\r\npull(distinct(df_act, id))\r\nNA\r\nthorough\r\n\r\nMeasurements\r\nRead the ‘stream’ data from Strava. A ‘stream’ is a nested list (json format) with all available measurements of the corresponding activity.\r\nTo get all available variables and turn the result into a data frame, define a helper function. This function takes an id of an activity and an authentication token, which we have created earlier.\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ndf_meas\r\nread_activity_stream(act_ids, my_sig)\r\nmap(act_ids)\r\nnever\r\n\r\n\r\n\r\nread_activity_stream <- function(id, sig) {\r\n  act_url <- parse_url(stringr::str_glue(\r\n    \"https://www.strava.com/api/v3/activities/{id}/streams\"))\r\n  access_token <- sig$credentials$access_token[[1]]\r\n\r\n  r <- modify_url(\r\n    act_url,\r\n    query = list(\r\n      access_token = access_token,\r\n      keys = str_glue(\r\n        \"distance,time,latlng,altitude,velocity_smooth,heartrate,cadence,\",\r\n        \"watts,temp,moving,grade_smooth\"))) %>%\r\n    GET()\r\n\r\n  stop_for_status(r)\r\n\r\n  fromJSON(content(r, as = \"text\"), flatten = TRUE) %>%\r\n    as_tibble() %>%\r\n    mutate(id = id)\r\n}\r\n\r\n\r\n\r\nThe target is defined with dynamic branching which maps over all activity ids. Define the cue mode as never to make sure, that every target runs exactly once.\r\nBind the single targets into one data frame:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ndf_meas_all\r\nbind_rows(df_meas)\r\nNA\r\nthorough\r\n\r\nThe data now is represented by one row per measurement series:\r\n\r\n# A tibble: 4,846 x 6\r\n   type            data     series_type original_size resolution id   \r\n   <chr>           <list>   <chr>               <int> <chr>      <chr>\r\n 1 moving          <lgl [8~ distance             8287 high       6289~\r\n 2 latlng          <dbl [8~ distance             8287 high       6289~\r\n 3 velocity_smooth <dbl [8~ distance             8287 high       6289~\r\n 4 grade_smooth    <dbl [8~ distance             8287 high       6289~\r\n 5 distance        <dbl [8~ distance             8287 high       6289~\r\n 6 altitude        <dbl [8~ distance             8287 high       6289~\r\n 7 heartrate       <int [8~ distance             8287 high       6289~\r\n 8 time            <int [8~ distance             8287 high       6289~\r\n 9 moving          <lgl [3~ distance              341 high       6271~\r\n10 latlng          <dbl [3~ distance              341 high       6271~\r\n# ... with 4,836 more rows\r\n\r\nTurn the data into a wide format:\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ndf_meas_wide\r\nmeas_wide(df_meas_all)\r\nNA\r\nthorough\r\n\r\n\r\n\r\nmeas_wide <- function(df_meas) {\r\n  pivot_wider(df_meas, names_from = type, values_from = data)\r\n}\r\n\r\n\r\n\r\nIn this format every activity is one row again:\r\n\r\n# A tibble: 608 x 14\r\n   series_type original_size resolution id         moving    latlng   \r\n   <chr>               <int> <chr>      <chr>      <list>    <list>   \r\n 1 distance             8287 high       6289431308 <lgl [8,~ <dbl [8,~\r\n 2 distance              341 high       6271965619 <lgl [34~ <dbl [34~\r\n 3 distance              253 high       6250666002 <lgl [25~ <dbl [25~\r\n 4 distance             4706 high       6218628649 <lgl [4,~ <dbl [4,~\r\n 5 distance              301 high       6213800583 <lgl [30~ <dbl [30~\r\n 6 distance             4905 high       6179655557 <lgl [4,~ <dbl [4,~\r\n 7 distance            10640 high       6160486739 <lgl [10~ <dbl [10~\r\n 8 distance             4969 high       6153936896 <lgl [4,~ <dbl [4,~\r\n 9 distance             2073 high       6115020306 <lgl [2,~ <dbl [2,~\r\n10 distance             1158 high       6097842884 <lgl [1,~ <dbl [1,~\r\n# ... with 598 more rows, and 8 more variables:\r\n#   velocity_smooth <list>, grade_smooth <list>, distance <list>,\r\n#   altitude <list>, heartrate <list>, time <list>, cadence <list>,\r\n#   watts <list>\r\n\r\nPreprocess and unnest the data. The column latlng needs special attention, because it contains latitude and longitude information. Separate the two measurements before unnesting all list columns.\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ndf_meas_pro\r\nmeas_pro(df_meas_wide)\r\nNA\r\nthorough\r\n\r\n\r\n\r\nmeas_pro <- function(df_meas_wide) {\r\n  df_meas_wide %>%\r\n    mutate(\r\n      lat = map_if(\r\n        .x = latlng, .p = ~ !is.null(.x), .f = ~ .x[, 1]),\r\n      lng = map_if(\r\n        .x = latlng, .p = ~ !is.null(.x), .f = ~ .x[, 2])) %>%\r\n    select(-c(latlng, original_size, resolution, series_type)) %>%\r\n    unnest(where(is_list))\r\n}\r\n\r\n\r\n\r\nAfter this step every row is one point in time and every column is (if present) a measurement at this point in time.\r\n\r\n# A tibble: 2,185,807 x 12\r\n   id         moving velocity_smooth grade_smooth distance altitude\r\n   <chr>      <lgl>            <dbl>        <dbl>    <dbl>    <dbl>\r\n 1 6289431308 FALSE             0               0      0       539.\r\n 2 6289431308 TRUE              0               0      3.3     539.\r\n 3 6289431308 TRUE              0               0      9.9     539.\r\n 4 6289431308 TRUE              5.35            0     16.1     539.\r\n 5 6289431308 TRUE              5.44            0     21.8     539.\r\n 6 6289431308 TRUE              5.51            0     27.5     539.\r\n 7 6289431308 TRUE              6.04            0     33.5     539.\r\n 8 6289431308 TRUE              5.89            0     39.3     539.\r\n 9 6289431308 TRUE              5.83            0     45.2     539.\r\n10 6289431308 TRUE              5.88            0     51.1     539.\r\n# ... with 2,185,797 more rows, and 6 more variables:\r\n#   heartrate <int>, time <int>, cadence <int>, watts <int>,\r\n#   lat <dbl>, lng <dbl>\r\n\r\nVisualisation\r\nVisualize the final data by displaying the geospatial information in the data. Every facet is one activity. Keep the rest of the plot as minimal as possible.\r\n\r\nname\r\ncommand\r\npattern\r\ncue_mode\r\ngg_meas\r\nvis_meas(df_meas_rel)\r\nNA\r\nthorough\r\n\r\n\r\n\r\nvis_meas <- function(df_meas_pro) {\r\n  df_meas_pro %>%\r\n    filter(!is.na(lat)) %>%\r\n    ggplot(aes(x = lng, y = lat)) +\r\n    geom_path() +\r\n    facet_wrap(~ id, scales = \"free\") +\r\n    theme(\r\n      axis.line = element_blank(),\r\n      axis.text.x = element_blank(),\r\n      axis.text.y = element_blank(),\r\n      axis.ticks = element_blank(),\r\n      axis.title.x = element_blank(),\r\n      axis.title.y = element_blank(),\r\n      legend.position = \"bottom\",\r\n      panel.background = element_blank(),\r\n      panel.border = element_blank(),\r\n      panel.grid.major = element_blank(),\r\n      panel.grid.minor = element_blank(),\r\n      plot.background = element_blank(),\r\n      strip.text = element_blank())\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/strava-data/distill-preview.png",
    "last_modified": "2021-11-22T22:32:14+01:00",
    "input_file": {},
    "preview_width": 2100,
    "preview_height": 2100
  },
  {
    "path": "posts/hour-record/",
    "title": "Hour Record",
    "description": "Article about the development of the cycling hour record",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-11-05",
    "categories": [],
    "contents": "\r\nIdea\r\nVisualise the development of the cycling hour record. It is a record attempt of cyclyst, who try to cover the longest possible distance in one hour. Since 2014 there are unified rules for the hour record. Since then there were 6 different record holders. Explore how these records compare to each other.\r\nThe analysis is realised in a target plan. Look at the graph representation of this plan:\r\n\r\n\r\n{\"x\":{\"nodes\":{\"name\":[\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"hour_record\",\"hour_record_post\",\"rel_urls\",\"vis_average_speed\",\"time_splits\",\"time_splits_raw\"],\"type\":[\"stem\",\"pattern\",\"stem\",\"stem\",\"stem\",\"stem\",\"function\",\"function\",\"function\"],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"outdated\",\"started\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\"],\"seconds\":[0.16,0.9,0.01,8.69,10.78,0,null,null,null],\"bytes\":[1181,16261,42718,1885484,1713403,151,null,null,null],\"branches\":[null,6,null,null,null,null,null,null,null],\"id\":[\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"hour_record\",\"hour_record_post\",\"rel_urls\",\"vis_average_speed\",\"time_splits\",\"time_splits_raw\"],\"label\":[\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"hour_record\",\"hour_record_post\",\"rel_urls\",\"vis_average_speed\",\"time_splits\",\"time_splits_raw\"],\"level\":[3,2,4,5,5,1,1,1,1],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#78B7C5\",\"#DC863B\",\"#354823\",\"#354823\",\"#354823\",\"#354823\"],\"shape\":[\"dot\",\"square\",\"dot\",\"dot\",\"dot\",\"dot\",\"triangle\",\"triangle\",\"triangle\"]},\"edges\":{\"from\":[\"df_time_splits\",\"vis_average_speed\",\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"rel_urls\",\"rel_urls\",\"time_splits_raw\",\"df_time_splits\",\"df_time_splits_raw\",\"gg_average_speed\",\"rel_urls\",\"df_time_splits_raw\",\"time_splits\"],\"to\":[\"gg_average_speed\",\"gg_average_speed\",\"hour_record_post\",\"hour_record_post\",\"hour_record_post\",\"hour_record_post\",\"df_time_splits_raw\",\"df_time_splits_raw\",\"hour_record\",\"hour_record\",\"hour_record\",\"hour_record\",\"df_time_splits\",\"df_time_splits\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Outdated\",\"Started\",\"Stem\",\"Pattern\",\"Function\"],\"color\":[\"#354823\",\"#78B7C5\",\"#DC863B\",\"#899DA4\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"square\",\"triangle\"]},\"nodesToDataframe\":true}},\"evals\":[],\"jsHooks\":[]}\r\nData\r\nGet the data from the following urls: http://www.wolfgang-menn.de/voigt.htm, http://www.wolfgang-menn.de/braendle.htm, http://www.wolfgang-menn.de/dennis.htm, http://www.wolfgang-menn.de/dowsett.htm, http://www.wolfgang-menn.de/wiggins.htm, http://www.wolfgang-menn.de/campenaerts.htm\r\nMap over the different urls and save the data along with the url adress:\r\n\r\n\r\ntime_splits_raw <- function(url) {\r\n  resp <- request(url) |>\r\n    req_perform()\r\n\r\n  df_splits <- resp |>\r\n    resp_body_html() |>\r\n    html_elements(xpath = \"/html/body/div/table\") |>\r\n    html_table() |>\r\n    first() |>\r\n    mutate(across(everything(), as.character))\r\n\r\n  tibble(url = url, time_splits = list(df_splits))\r\n}\r\n\r\n\r\n\r\n\r\n# A tibble: 6 x 2\r\n  url                                         time_splits        \r\n  <chr>                                       <list>             \r\n1 http://www.wolfgang-menn.de/voigt.htm       <tibble [28 x 104]>\r\n2 http://www.wolfgang-menn.de/braendle.htm    <tibble [23 x 79]> \r\n3 http://www.wolfgang-menn.de/dennis.htm      <tibble [25 x 89]> \r\n4 http://www.wolfgang-menn.de/dowsett.htm     <tibble [25 x 89]> \r\n5 http://www.wolfgang-menn.de/wiggins.htm     <tibble [27 x 99]> \r\n6 http://www.wolfgang-menn.de/campenaerts.htm <tibble [23 x 99]> \r\n\r\nPreprocessing of the raw data. Extract the rider name and preprocess the kpi columns.\r\n\r\n\r\ntime_splits <- function(df_time_splits_raw) {\r\n  df_time_splits_raw |>\r\n    mutate(time_splits = map(time_splits, ~ filter(.x, str_detect(X1, \"^\\\\d+$\")))) |>\r\n    unnest(time_splits) |>\r\n    select(where(~ !all(is.na(.x)))) |>\r\n    transmute(\r\n      rider = str_to_title(str_remove(\r\n        map_chr(str_split(url, \"/\"), 4), \"\\\\.htm\")),\r\n      km = parse_integer(X1),\r\n      time = ms(str_remove(X4, \"\\\\.\\\\d+$\")), km_h = parse_number(X5)) |>\r\n    filter(!is.na(km_h))\r\n}\r\n\r\n\r\n\r\n\r\n# A tibble: 79 x 4\r\n   rider    km time      km_h\r\n   <chr> <int> <Period> <dbl>\r\n 1 Voigt     1 1M 14S    48.6\r\n 2 Voigt     5 5M 56S    50.5\r\n 3 Voigt    10 11M 48S   50.8\r\n 4 Voigt    15 17M 42S   50.8\r\n 5 Voigt    20 23M 39S   50.7\r\n 6 Voigt    25 29M 36S   50.7\r\n 7 Voigt    30 35M 32S   50.6\r\n 8 Voigt    35 41M 27S   50.7\r\n 9 Voigt    40 47M 26S   50.8\r\n10 Voigt    45 53M 1S    50.9\r\n# ... with 69 more rows\r\n\r\nVisualisation\r\nPlot the development of the average speeds. Differentiate the riders by color:\r\n\r\n\r\nvis_average_speed <- function(df_time_splits) {\r\n  df_time_splits |>\r\n    ggplot(aes(x = km, y = km_h, color = rider)) +\r\n      geom_point() +\r\n      geom_line() +\r\n      labs(\r\n        y = \"Average Speed\", x = \"Kilometer\",\r\n        title = \"Development of Speeds by Hour Record Attempt\",\r\n        subtitle = \"Different Riders are represented by color\") +\r\n      theme_light() +\r\n      theme(legend.position = \"bottom\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/hour-record/distill-preview.png",
    "last_modified": "2021-11-05T23:14:31+01:00",
    "input_file": {}
  },
  {
    "path": "posts/hex_sticker/",
    "title": "Hex Sticker",
    "description": "How to create a hex sticker for a new package",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-05-23",
    "categories": [],
    "contents": "\r\nIn this post, I want to describe how I created a hex sticker for one of my shiny apps. The app itself lets users interactively explore their Strava data.\r\nBecause I called the app SummitR, I decided to display one of the most famous summit finishes in cycling history: Alpe d’Huez.\r\nI am using the following packages:\r\n\r\n\r\nlibrary(hexSticker)\r\nlibrary(tidyverse)\r\nlibrary(pins)\r\n\r\n\r\n\r\nThe hexSticker package is used to create the final sticker.\r\nBecause I already climbed Alpe d’Huez on a previous occasion, I can get the data already prepared from a private github repository. The data in the corresponding repository is organised as a pin:\r\n\r\n\r\nalpe_dhuez_id <- \"1714646144\"\r\nathlete_id <- \"26845822\"\r\n\r\nboard_register_github(repo = \"duju211/strava_act\", branch = \"master\")\r\n\r\ndf_act <- pin_get(\r\n  str_glue(\"act_{alpe_dhuez_id}_{athlete_id}\"), board = \"github\")\r\n\r\nboard_disconnect(\"github\")\r\n\r\n\r\n\r\nIn raw table form the data of the activity looks like this:\r\n\r\n# A tibble: 5,326 x 11\r\n   moving velocity_smooth grade_smooth distance altitude  time   lat\r\n   <lgl>            <dbl>        <dbl>    <dbl>    <dbl> <int> <dbl>\r\n 1 FALSE              0            8.6      0       787      0  45.1\r\n 2 TRUE               0            8.6      2.1     787.     1  45.1\r\n 3 TRUE               2.3          8.6      4.5     787.     2  45.1\r\n 4 TRUE               2.3         10        7       788.     3  45.1\r\n 5 TRUE               2.3         11.9      9.3     788.     4  45.1\r\n 6 TRUE               2.3         12       11.6     788      5  45.1\r\n 7 TRUE               2.4         11.9     14.1     788.     6  45.1\r\n 8 TRUE               2.4         13.6     16.3     789.     7  45.1\r\n 9 TRUE               2.3         12       18.7     789      8  45.1\r\n10 TRUE               2.4         12.6     21.1     789.     9  45.1\r\n# ... with 5,316 more rows, and 4 more variables: lng <dbl>,\r\n#   heartrate <int>, cadence <int>, watts <int>\r\n\r\nCreate a minimalistic plot of the activity. Only take variables lat and lng into account:\r\n\r\n\r\ngg_act <- df_act %>% \r\n  ggplot(aes(x = lng, y = lat)) +\r\n  geom_path(color = \"white\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\nPlot the path of the activity on a black background:\r\n\r\n\r\ngg_act +\r\n  theme_dark()\r\n\r\n\r\n\r\n\r\nSave the finished hex sticker as result. Use the official Strava color as background color.\r\n\r\n\r\nsticker(\r\n  gg_act, package=\"SummitR\", p_size=20, s_x=1.1, s_y=.75, s_width=1.3,\r\n  s_height=1, h_fill = \"#fc4c02\", h_color = \"white\",\r\n  filename=\"_posts/hex_sticker/hex_sticker.png\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/hex_sticker/distill-preview.png",
    "last_modified": "2021-05-23T20:22:01+02:00",
    "input_file": {}
  },
  {
    "path": "posts/transalp/",
    "title": "Getting Over It",
    "description": "Visualising my Transalp bike ride",
    "author": [
      {
        "name": "Julian During",
        "url": {}
      }
    ],
    "date": "2021-05-23",
    "categories": [],
    "contents": "\r\nThis summer I crossed the alps with my road bike. I’ve recorded the whole ride and as a nice memory, I would like to visualise this ride.\r\nA short time ago I’ve discovered the awesome R package drake. The use of this package transformed the way I do my analysis and it helps me to make my post more reproducible. The following blog post describes the underlying workflow, after which I’ve developed the underlying package transalp for this post.\r\nData\r\nAt first you have to install the package from github. Then you have to load it.\r\n\r\n\r\nremotes::install_github(\"duju211/transalp\")\r\n\r\nlibrary(transalp)\r\n\r\n\r\n\r\nLoad the other necessary libraries:\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(patchwork)\r\nlibrary(drake)\r\nlibrary(here)\r\nlibrary(fs)\r\n\r\n\r\n\r\nThe package includes the underlying data:\r\n\r\n\r\ndf_act_meas_raw <- transalp::df_act_meas\r\n\r\n\r\n\r\n\r\n# A tibble: 90,917 x 10\r\n   id         act_date   moving velocity_smooth grade_smooth distance\r\n   <chr>      <date>     <lgl>            <dbl>        <dbl>    <dbl>\r\n 1 3669729902 2020-06-25 FALSE              0            0        0  \r\n 2 3669729902 2020-06-25 FALSE              0            0        0.9\r\n 3 3669729902 2020-06-25 TRUE               0          -44.6      4.6\r\n 4 3669729902 2020-06-25 TRUE               0            1.4      8.4\r\n 5 3669729902 2020-06-25 TRUE               0            2.8     12.1\r\n 6 3669729902 2020-06-25 TRUE               0            2.8     15.6\r\n 7 3669729902 2020-06-25 TRUE               0            1.4     19.1\r\n 8 3669729902 2020-06-25 TRUE               3.6          1.4     22.5\r\n 9 3669729902 2020-06-25 TRUE               3.5          0       26  \r\n10 3669729902 2020-06-25 TRUE               3.5          1.6     29.5\r\n# ... with 90,907 more rows, and 4 more variables: altitude <dbl>,\r\n#   time <int>, lat <dbl>, lng <dbl>\r\n\r\nPreprocessing\r\nLook at the first function:\r\n\r\n\r\n#' Function to preprocess measurements of the included activities.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return Preprocessed activities\r\n#' @export\r\n#'\r\n#' @examples\r\n#' pre_process_meas(df_act_meas)\r\npre_process_meas <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    dplyr::mutate(\r\n      act_date_chr = as.character(act_date),\r\n      altitude_norm = altitude / max(altitude)) %>%\r\n    dplyr::group_by(id) %>%\r\n    dplyr::mutate(distance_norm = distance / max(distance)) %>%\r\n    dplyr::ungroup()\r\n}\r\n\r\n\r\n\r\nThe function does some basic preprocessing on the included activities:\r\nTurn activity date into character (for easier plotting)\r\nNormalize altitude and distance\r\n\r\n\r\ndf_act_meas <- pre_process_meas(df_act_meas_raw)\r\n\r\n\r\n\r\nNest the data frame by id and act_date_chr. Create a new sf column with the geospatial information of the activities:\r\n\r\n\r\n#' Turn every activity into an sf object. Nest the data frame by 'id' and\r\n#' 'act_date_chr' to do this.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return sf object\r\n#' @export\r\n#'\r\n#' @examples\r\nconvert_to_sf <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    tidyr::nest(act_data = -c(id, act_date_chr)) %>%\r\n    dplyr::mutate(\r\n      line = purrr::map(\r\n        act_data,\r\n        ~ sf::st_linestring(as.matrix(.x[, c(\"lng\", \"lat\", \"altitude\")]))),\r\n      geom = purrr::map(line, sf::st_sfc, crs = 4326)) %>%\r\n    sf::st_as_sf()\r\n}\r\n\r\n\r\n\r\n\r\n\r\nsf_act_meas <- convert_to_sf(df_act_meas)\r\n\r\n\r\n\r\n\r\nSimple feature collection with 5 features and 4 fields\r\nGeometry type: LINESTRING\r\nDimension:     XYZ\r\nBounding box:  xmin: 8.317612 ymin: 46.0061 xmax: 9.035269 ymax: 48.21307\r\nz_range:       zmin: 206.8 zmax: 2477.6\r\nCRS:           NA\r\n# A tibble: 5 x 5\r\n  id     act_date_chr act_data                             line geom  \r\n  <chr>  <chr>        <list>                       <LINESTRING> <list>\r\n1 36697~ 2020-06-25   <tibble [~ Z (8.596761 46.63501 1451.6, ~ <LINE~\r\n2 36646~ 2020-06-24   <tibble [~ Z (8.602206 46.63612 1510.2, ~ <LINE~\r\n3 36590~ 2020-06-23   <tibble [~ Z (8.625703 46.90152 447, 8.6~ <LINE~\r\n4 36542~ 2020-06-22   <tibble [~ Z (8.741265 47.49397 432, 8.7~ <LINE~\r\n5 36504~ 2020-06-21   <tibble [~ Z (9.021049 48.21307 750.2, 9~ <LINE~\r\n\r\nExtract the start point of every tour except for the last one. Extract the end point for this tour.\r\n\r\n\r\n#' Extract points of interest.\r\n#'\r\n#' @param sf_act_meas\r\n#'\r\n#' @return Data frame with points of interest\r\n#' @export\r\n#'\r\n#' @examples\r\nextract_poi <- function(sf_act_meas) {\r\n  sf_act_meas %>%\r\n    tibble::as_tibble() %>%\r\n    dplyr::transmute(\r\n      id, first_row = purrr::map(act_data, ~ .x[1,]),\r\n      last_row = purrr::map(act_data, ~ .x[nrow(.x), ]),\r\n      decisive_row = dplyr::if_else(id == \"3669729902\", last_row, first_row)) %>%\r\n    tidyr::unnest(decisive_row) %>%\r\n    dplyr::select(where(purrr::negate(purrr::is_list))) %>%\r\n    dplyr::mutate(\r\n      poi_name = dplyr::case_when(\r\n        act_date == \"2020-06-21\" ~ \"Albstadt\",\r\n        act_date == \"2020-06-22\" ~ \"Winterthur\",\r\n        act_date == \"2020-06-23\" ~ \"Flüelen\",\r\n        act_date == \"2020-06-24\" ~ \"Andermatt\",\r\n        act_date == \"2020-06-25\" ~ \"Lugano\",\r\n        TRUE ~ NA_character_)) %>%\r\n    dplyr::rename(lon = lng)\r\n}\r\n\r\n\r\n\r\n\r\n\r\ndf_poi <- extract_poi(sf_act_meas)\r\n\r\n\r\n\r\nVisualisation\r\nAltitude\r\nVisualise the altitude data:\r\n\r\n\r\n#' Visualise the altitude by using a ridge plot.\r\n#'\r\n#' @param df_act_meas\r\n#'\r\n#' @return ggplot of altitude data\r\n#' @export\r\n#'\r\n#' @examples\r\nvis_altitude_ridge <- function(df_act_meas) {\r\n  df_act_meas %>%\r\n    tibble::as_tibble() %>%\r\n    tidyr::unnest_legacy(act_data) %>%\r\n    dplyr::mutate(distance = distance / 1000) %>%\r\n    ggplot2::ggplot(ggplot2::aes(\r\n      x = distance, y = act_date_chr, height = altitude,\r\n      group = act_date_chr, color = act_date_chr)) +\r\n    ggridges::geom_ridgeline(scale = 0.0025, alpha = 0.2) +\r\n    ggplot2::labs(\r\n      x = \"Distance [km]\", y = ggplot2::element_blank()) +\r\n    ggplot2::theme_light() +\r\n    ggplot2::theme(\r\n      legend.position = \"none\") +\r\n    ggplot2::scale_y_discrete(position = \"right\") +\r\n    ggplot2::scale_x_continuous(breaks = scales::breaks_width(10))\r\n}\r\n\r\n\r\n\r\nThe function mainly applies the ggridges::geom_ridgeline function to the data. A form of visualisation that I’ve already used a lot. Its style is reminiscent of the famous Joy Division album cover.\r\n\r\n\r\ngg_altitude_ridges <- vis_altitude_ridge(sf_act_meas)\r\n\r\n\r\n\r\n\r\n\r\n\r\nSpatial Data\r\nDetermine the map data for all the activities. Use the ggmap::get_stamenmap function to download the data. The bounding box is calculated from the sf_act_meas object.\r\n\r\n\r\n#' Get the ground map for the visualisation of the spatial data.\r\n#'\r\n#' @param sf_act_meas\r\n#' @param tol_bbox\r\n#' @param map_zoom\r\n#'\r\n#' @return\r\n#' @export\r\n#'\r\n#' @examples\r\nget_alpen_map <- function(sf_act_meas, tol_bbox = 0.015, map_zoom = 10) {\r\n  bbox <- sf::st_bbox(sf_act_meas)\r\n\r\n  stamen_map <- ggmap::get_stamenmap(\r\n    bbox = c(\r\n      left = bbox$xmin[[1]] - tol_bbox,\r\n      right = bbox$xmax[[1]] + tol_bbox,\r\n      bottom = bbox$ymin[[1]] - tol_bbox,\r\n      top = bbox$ymax[[1]] + tol_bbox),\r\n    maptype = \"terrain-background\", zoom = map_zoom, color = \"bw\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\ngg_alpen <- get_alpen_map(sf_act_meas, tol_bbox = 0.1, map_zoom = 9)\r\n\r\n\r\n\r\n\r\n\r\n\r\nPlot the activity and the point of interest data onto the map. Use the ggrepel package to plot the labels of the points of interest. This avoids too much overplotting.\r\n\r\n\r\n#' Plot the spatial data (route + point of interest) onto the map\r\n#'\r\n#' @param sf_act_meas\r\n#' @param gg_alpen\r\n#'\r\n#' @return ggplot of spatial data\r\n#' @export\r\n#'\r\n#' @examples\r\nvis_ride <- function(sf_act_meas, gg_alpen, df_poi) {\r\n  ggmap::ggmap(gg_alpen) +\r\n    ggplot2::geom_sf(\r\n      data = sf_act_meas, inherit.aes = FALSE,\r\n      mapping = aes(color = act_date_chr), size = 1.2) +\r\n    ggrepel::geom_label_repel(\r\n      data = df_poi, mapping = aes(label = poi_name), alpha = 0.6,\r\n      family = \"Fira Code Retina\", size = 2.5) +\r\n    ggplot2::theme_light() +\r\n    ggplot2::labs(\r\n      x = \"Longitude\", y = \"Latitude\") +\r\n    ggplot2::theme(legend.position = \"none\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\ngg_rides <- vis_ride(sf_act_meas, gg_alpen_map, df_poi)\r\n\r\n\r\n\r\n\r\n\r\n\r\nCombine Visualisations\r\nCombine everything into one big plot using the patchwork package:\r\n\r\n\r\n# extrafont::font_import()\r\nextrafont::loadfonts(device = \"win\")\r\n\r\nfinal_plot <- (gg_rides + gg_altitude_ridges) +\r\n      plot_annotation(\r\n        title = \"Transalp 2020\",\r\n        subtitle = \"Albstadt - Lugano\") &\r\n      theme(text = element_text(family = \"Fira Code Retina\"))\r\n\r\nfinal_plot\r\n\r\n\r\n\r\n\r\nThe extrafont package helps with using some fancy fonts. The font_import function has to be called once. Comment the function call in the above code chunk because of this.\r\n\r\n\r\n\r\n",
    "preview": "posts/transalp/distill-preview.png",
    "last_modified": "2021-05-23T20:22:01+02:00",
    "input_file": {}
  }
]
